<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🤖 AI 자동 분리수거 시스템</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
            text-align: center;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: #2d2d2d;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        h1 {
            color: #4CAF50;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        #video {
            width: 100%;
            max-width: 640px;
            height: 480px;
            border: 3px solid #4CAF50;
            border-radius: 10px;
            background: #000;
            margin: 20px 0;
        }
        
        .controls {
            margin: 20px 0;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #45a049;
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        #result {
            font-size: 24px;
            font-weight: bold;
            margin: 20px 0;
            padding: 20px;
            border-radius: 10px;
            background: #333;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .status {
            background: #444;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .processing {
            color: #FFC107;
        }
        
        .detected {
            color: #4CAF50;
        }
        
        .waiting {
            color: #2196F3;
        }
        
        .error {
            color: #f44336;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🤖 AI 자동 분리수거 시스템</h1>
        
        <video id="video" autoplay muted playsinline></video>
        
        <div class="controls">
            <select id="cameraSelect" style="padding: 10px; margin: 10px; border-radius: 8px; background: #444; color: white; border: 2px solid #4CAF50; font-size: 14px;">
                <option value="">카메라를 선택하세요...</option>
            </select>
            <button onclick="startCamera()">📷 카메라 시작</button>
            <button onclick="stopCamera()">⏹️ 카메라 중지</button>
            <button onclick="decreaseSensitivity()">🔽 민감도 낮추기</button>
            <button onclick="increaseSensitivity()">🔼 민감도 높이기</button>
            <button onclick="checkServer()">🔍 서버 상태 확인</button>
            <button onclick="debugServerRequest()">🐛 서버 디버그</button>
            <button onclick="testServerWithImage()">📤 서버 POST 테스트</button>
            <button onclick="testClassification()">🧪 분류 테스트</button>
            <button onclick="toggleAuto()" id="autoBtn">🔄 자동 분류 시작</button>
            <button onclick="connectSerial()">🔌 시리얼 연결</button>
        </div>
        
                         <div id="result">시스템 준비 중...</div>
        <div id="status" class="status">카메라를 시작해주세요</div>
        <div id="sensitivity" class="status" style="background: #333; color: #FFC107;">
            🎚️ 변화 감지 민감도: <span id="sensitivityValue">15.0%</span>
        </div>
        
        <!-- 시리얼 통신 모니터링 섹션 -->
        <div class="serial-monitor" style="margin-top: 20px;">
            <h3 style="color: #4CAF50; margin-bottom: 10px;">📡 아두이노 시리얼 모니터</h3>
            <div class="serial-controls" style="margin-bottom: 10px;">
                <button onclick="connectArduino()" id="connectBtn">🔌 아두이노 연결</button>
                <button onclick="disconnectArduino()" id="disconnectBtn" disabled>🔌 연결 해제</button>
                <button onclick="clearSerialLog()">🗑️ 로그 지우기</button>
                <button onclick="sendTestCommand()">🧪 테스트 명령</button>
            </div>
            <div id="serialStatus" class="status" style="background: #444;">
                🔌 아두이노 연결 상태: <span id="connectionStatus">연결 안됨</span>
            </div>
            <div class="serial-log-container" style="background: #000; border: 2px solid #4CAF50; border-radius: 8px; height: 200px; overflow-y: auto; padding: 10px; font-family: 'Courier New', monospace; font-size: 12px;">
                <div id="serialLog" style="color: #00FF00;"></div>
            </div>
            <div class="manual-command" style="margin-top: 10px;">
                <input type="text" id="manualCommand" placeholder="수동 명령어 입력 (예: STATUS, HOME, TEST)" 
                       style="padding: 8px; width: 70%; border-radius: 5px; border: 1px solid #4CAF50; background: #333; color: white;">
                <button onclick="sendManualCommand()" style="padding: 8px 15px; margin-left: 5px;">📤 전송</button>
            </div>
        </div>
    </div>

    <script>
                 // 전역 변수들
         let auto = false;
         let intervalId = null;
         let port = null;
         let writer = null;
         let reader = null;
         let currentStream = null;
         let isProcessing = false;
         let serialConnected = false;
         let readLoop = null;
        
        // 배경 학습 및 최적화 변수들
        let backgroundModel = null;
        let backgroundFrameCount = 0;
        let backgroundLearningComplete = false;
        let previousFrame = null;
        let frameBuffer = [];
                 let changeThreshold = 0.15; // 15% 변화 감지 (더 둔하게)
         
         // 자동 최적화 설정
         const AUTO_CONFIG = {
             backgroundLearningFrames: 50,
             monitoringInterval: 800,  // 0.8초마다 체크 (더 느리게)
             classificationDelay: 2000, // 2초 대기 후 분류 (더 길게)
             stabilizationFrames: 5,
             noiseReduction: true,
             edgeEnhancement: true,
             colorSpaceOptimization: true
         };

        // 카메라 목록 업데이트
        async function updateCameraList() {
            try {
                // 먼저 권한 요청을 위해 임시 스트림 생성
                const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                tempStream.getTracks().forEach(track => track.stop());
                
                // 이제 실제 디바이스 목록 가져오기
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                const select = document.getElementById('cameraSelect');
                
                // 기존 옵션 제거 (첫 번째 기본 옵션 제외)
                while (select.children.length > 1) {
                    select.removeChild(select.lastChild);
                }
                
                if (videoDevices.length === 0) {
                    document.getElementById('status').innerHTML = '❌ 사용 가능한 카메라가 없습니다';
                    return;
                }
                
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `카메라 ${index + 1}`;
                    select.appendChild(option);
                });
                
                // 첫 번째 카메라를 기본으로 선택
                if (videoDevices.length > 0) {
                    select.selectedIndex = 1;
                }
                
                document.getElementById('status').innerHTML = `📷 ${videoDevices.length}개의 카메라 발견됨 - 카메라를 선택하고 시작하세요`;
                
            } catch (error) {
                console.error('카메라 목록 오류:', error);
                document.getElementById('status').innerHTML = '❌ 카메라 접근 권한이 필요합니다';
            }
        }

        // 카메라 시작
        async function startCamera() {
            try {
                // 기존 스트림 정리
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                    currentStream = null;
                }
                
                document.getElementById('status').innerHTML = '📷 카메라 초기화 중...';
                
                const selectedDeviceId = document.getElementById('cameraSelect').value;
                
                if (!selectedDeviceId) {
                    document.getElementById('status').innerHTML = '⚠️ 카메라를 먼저 선택해주세요';
                    return;
                }
                
                const constraints = {
                    video: {
                        deviceId: { exact: selectedDeviceId },
                        width: { ideal: 640, min: 320 },
                        height: { ideal: 480, min: 240 },
                        frameRate: { ideal: 30, min: 15 }
                    }
                };
                
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                const video = document.getElementById('video');
                video.srcObject = currentStream;
                
                // 비디오 로드 대기
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play().then(() => {
                            const selectedOption = document.getElementById('cameraSelect').selectedOptions[0];
                            document.getElementById('status').innerHTML = `✅ ${selectedOption.text} 준비 완료`;
                            document.getElementById('result').innerHTML = '카메라가 준비되었습니다. 자동 분류를 시작할 수 있습니다.';
                            resolve();
                        }).catch((playError) => {
                            console.error('비디오 재생 오류:', playError);
                            document.getElementById('status').innerHTML = '❌ 비디오 재생 실패';
                        });
                    };
                    
                    video.onerror = (videoError) => {
                        console.error('비디오 오류:', videoError);
                        document.getElementById('status').innerHTML = '❌ 비디오 로드 실패';
                    };
                });
                
            } catch (error) {
                console.error('카메라 오류:', error);
                let errorMessage = '카메라 연결 실패';
                
                if (error.name === 'NotFoundError') {
                    errorMessage = '선택한 카메라를 찾을 수 없습니다';
                } else if (error.name === 'NotAllowedError') {
                    errorMessage = '카메라 접근 권한이 거부되었습니다';
                } else if (error.name === 'NotReadableError') {
                    errorMessage = '카메라가 다른 앱에서 사용 중입니다';
                } else if (error.name === 'OverconstrainedError') {
                    errorMessage = '카메라가 요구사항을 지원하지 않습니다';
                }
                
                document.getElementById('status').innerHTML = `❌ ${errorMessage}`;
                document.getElementById('result').innerHTML = '카메라 연결 실패 - 다른 카메라를 선택해보세요';
            }
        }

                 // 카메라 중지
         function stopCamera() {
             if (currentStream) {
                 currentStream.getTracks().forEach(track => track.stop());
                 currentStream = null;
                 
                 const video = document.getElementById('video');
                 video.srcObject = null;
                 
                 document.getElementById('status').innerHTML = '📷 카메라가 중지되었습니다';
                 document.getElementById('result').innerHTML = '카메라를 다시 시작하세요';
             }
         }

         // 민감도 조절 함수들
         function decreaseSensitivity() {
             changeThreshold = Math.min(0.5, changeThreshold + 0.05); // 최대 50%까지 둔하게
             updateSensitivityDisplay();
             document.getElementById('status').innerHTML = `🔽 민감도 낮춤 - 더 큰 변화만 감지`;
         }

         function increaseSensitivity() {
             changeThreshold = Math.max(0.05, changeThreshold - 0.05); // 최소 5%까지 민감하게
             updateSensitivityDisplay();
             document.getElementById('status').innerHTML = `🔼 민감도 높임 - 작은 변화도 감지`;
         }

         function updateSensitivityDisplay() {
             document.getElementById('sensitivityValue').textContent = `${(changeThreshold * 100).toFixed(1)}%`;
             
             // 민감도에 따른 색상 변경
             const sensitivityElement = document.getElementById('sensitivity');
             if (changeThreshold >= 0.3) {
                 sensitivityElement.style.color = '#FF6B6B'; // 빨간색 (매우 둔함)
             } else if (changeThreshold >= 0.2) {
                 sensitivityElement.style.color = '#FFC107'; // 노란색 (둔함)
             } else if (changeThreshold >= 0.1) {
                 sensitivityElement.style.color = '#4CAF50'; // 초록색 (보통)
             } else {
                 sensitivityElement.style.color = '#2196F3'; // 파란색 (민감함)
             }
         }

        // 자동 분류 토글
        function toggleAuto() {
            auto = !auto;
            const btn = document.getElementById('autoBtn');
            
            if (auto) {
                btn.textContent = '⏹️ 자동 분류 중지';
                btn.style.background = '#f44336';
                startAutoMode();
            } else {
                btn.textContent = '🔄 자동 분류 시작';
                btn.style.background = '#4CAF50';
                stopAutoMode();
            }
        }

        // 자동 모드 시작
        function startAutoMode() {
            document.getElementById('result').innerHTML = '🧠 AI 시스템 초기화 중...';
            document.getElementById('status').innerHTML = '📚 배경 학습 시작';
            
            // 배경 학습 초기화
            backgroundModel = null;
            backgroundFrameCount = 0;
            backgroundLearningComplete = false;
            previousFrame = null;
            frameBuffer = [];
            
            // 모니터링 시작
            intervalId = setInterval(monitorAndProcess, AUTO_CONFIG.monitoringInterval);
        }

        // 자동 모드 중지
        function stopAutoMode() {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            isProcessing = false;
            document.getElementById('result').innerHTML = '자동 분류가 중지되었습니다';
            document.getElementById('status').innerHTML = '대기 중...';
        }

        // 프레임 모니터링 및 처리
        function monitorAndProcess() {
            const video = document.getElementById('video');
            if (!video || video.videoWidth === 0) return;
            
            try {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                const currentFrame = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // 배경 학습 단계
                if (!backgroundLearningComplete) {
                    learnBackground(currentFrame);
                    return;
                }
                
                // 프레임 변화 감지 및 분류
                if (!isProcessing && detectSignificantChange(currentFrame)) {
                    isProcessing = true;
                    document.getElementById('result').innerHTML = '🗑️ 쓰레기 감지됨 - 1초 후 분석...';
                    document.getElementById('status').innerHTML = '⏳ 분류 준비 중...';
                    
                    setTimeout(() => {
                        captureAndClassify();
                    }, AUTO_CONFIG.classificationDelay);
                }
                
                // 이전 프레임 업데이트
                previousFrame = currentFrame;
                
            } catch (error) {
                console.error('모니터링 오류:', error);
            }
        }

        // 배경 학습
        function learnBackground(currentFrame) {
            backgroundFrameCount++;
            
            if (!backgroundModel) {
                // 첫 번째 프레임으로 초기화
                backgroundModel = new ImageData(
                    new Uint8ClampedArray(currentFrame.data), 
                    currentFrame.width, 
                    currentFrame.height
                );
                for (let i = 0; i < backgroundModel.data.length; i++) {
                    backgroundModel.data[i] = currentFrame.data[i];
                }
            } else {
                // 평균화로 배경 모델 업데이트
                const alpha = 0.1; // 학습률
                for (let i = 0; i < backgroundModel.data.length; i += 4) {
                    backgroundModel.data[i] = backgroundModel.data[i] * (1 - alpha) + currentFrame.data[i] * alpha;     // R
                    backgroundModel.data[i + 1] = backgroundModel.data[i + 1] * (1 - alpha) + currentFrame.data[i + 1] * alpha; // G
                    backgroundModel.data[i + 2] = backgroundModel.data[i + 2] * (1 - alpha) + currentFrame.data[i + 2] * alpha; // B
                }
            }
            
            const progress = Math.round((backgroundFrameCount / AUTO_CONFIG.backgroundLearningFrames) * 100);
            document.getElementById('status').innerHTML = `📚 배경 학습 중... ${progress}%`;
            
            if (backgroundFrameCount >= AUTO_CONFIG.backgroundLearningFrames) {
                backgroundLearningComplete = true;
                document.getElementById('result').innerHTML = '✅ AI 시스템 준비 완료 - 쓰레기 감지 대기 중';
                document.getElementById('status').innerHTML = '👁️ 실시간 모니터링 중...';
            }
        }

        // 유의미한 변화 감지
        function detectSignificantChange(currentFrame) {
            if (!backgroundModel || !previousFrame) return false;
            
            let totalDiff = 0;
            let pixelCount = 0;
            
            // 배경 차분 계산
            for (let i = 0; i < currentFrame.data.length; i += 4) {
                const currentR = currentFrame.data[i];
                const currentG = currentFrame.data[i + 1];
                const currentB = currentFrame.data[i + 2];
                
                const bgR = backgroundModel.data[i];
                const bgG = backgroundModel.data[i + 1];
                const bgB = backgroundModel.data[i + 2];
                
                // 유클리드 거리로 색상 차이 계산
                const colorDiff = Math.sqrt(
                    Math.pow(currentR - bgR, 2) + 
                    Math.pow(currentG - bgG, 2) + 
                    Math.pow(currentB - bgB, 2)
                );
                
                                 if (colorDiff > 60) { // 임계값을 높여서 더 큰 변화만 감지 (30 → 60)
                     totalDiff += colorDiff;
                     pixelCount++;
                 }
             }
             
             const changeRatio = pixelCount / (currentFrame.width * currentFrame.height);
             console.log(`변화 감지: ${(changeRatio * 100).toFixed(2)}% (임계값: ${(changeThreshold * 100).toFixed(1)}%)`);
             return changeRatio > changeThreshold;
        }

        // 이미지 전처리 및 최적화
        function preprocessImage(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 노이즈 감소 및 대비 향상
            for (let i = 0; i < data.length; i += 4) {
                // HSV 변환을 통한 색상 최적화
                const r = data[i] / 255;
                const g = data[i + 1] / 255;
                const b = data[i + 2] / 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const delta = max - min;
                
                // 채도 향상
                if (delta > 0.1) {
                    const saturation = delta / max;
                    const enhancedSaturation = Math.min(saturation * 1.2, 1);
                    
                    data[i] = Math.min(255, data[i] * (1 + enhancedSaturation * 0.3));
                    data[i + 1] = Math.min(255, data[i + 1] * (1 + enhancedSaturation * 0.3));
                    data[i + 2] = Math.min(255, data[i + 2] * (1 + enhancedSaturation * 0.3));
                }
                
                // 대비 자동 조정
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                const contrast = brightness < 128 ? 1.1 : 0.9;
                
                data[i] = Math.min(255, Math.max(0, (data[i] - 128) * contrast + 128));
                data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * contrast + 128));
                data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * contrast + 128));
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // 캡처 및 분류
        async function captureAndClassify() {
            try {
                const video = document.getElementById('video');
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                                 // 이미지 전처리 적용
                 const optimizedCanvas = preprocessImage(canvas);
                 
                 document.getElementById('result').innerHTML = '🤖 AI 분석 중...';
                 document.getElementById('status').innerHTML = '🧠 딥러닝 처리 중...';
                 
                 const blob = await new Promise(resolve => optimizedCanvas.toBlob(resolve, 'image/jpeg', 0.8));
                 
                 // 공통 분류 함수 사용
                 await classifyImage(blob);
                
                         } catch (error) {
                 console.error('분류 오류:', error);
                 // 오류 발생 시에도 데모 모드로 전환
                 document.getElementById('status').innerHTML = '🔄 오류 발생 - 데모 모드로 전환...';
                 
                 setTimeout(() => {
                     const demoLabels = ['plastic', 'paper', 'cardboard', 'glass', 'metal', 'trash'];
                     const randomLabel = demoLabels[Math.floor(Math.random() * demoLabels.length)];
                     const randomConfidence = 0.7 + Math.random() * 0.3;
                     
                     // 오류 시에도 한국어 매핑 적용
                     let errorUnified = '알 수 없음';
                     if (randomLabel === 'plastic') errorUnified = '플라스틱';
                     else if (randomLabel === 'paper' || randomLabel === 'cardboard') errorUnified = '종이';
                     else if (randomLabel === 'metal') errorUnified = '캔';
                     else if (randomLabel === 'glass' || randomLabel === 'trash') errorUnified = '비닐';
                     else errorUnified = '일반';
                     
                     document.getElementById('result').innerHTML = 
                         `🎯 분류 결과 (데모): <span style="color: #4CAF50">${errorUnified}</span><br>
                          <small>원본: ${randomLabel} | 신뢰도: ${(randomConfidence * 100).toFixed(1)}%</small><br>
                          <small style="color: #FFC107">⚠️ 서버 오류로 데모 모드 실행</small>`;
                     
                     document.getElementById('status').innerHTML = '📤 데모 결과 전송 중...';
                     
                     if (writer) {
                         sendToSerial(errorUnified);
                         document.getElementById('status').innerHTML = '✅ 데모 분류 완료';
                     } else {
                         document.getElementById('status').innerHTML = '⚠️ 시리얼 미연결';
                     }
                 }, 1000);
             } finally {
                 // 3초 후 다시 모니터링 시작
                 setTimeout(() => {
                     isProcessing = false;
                     if (auto) {
                         document.getElementById('result').innerHTML = '👁️ 쓰레기 감지 대기 중...';
                         document.getElementById('status').innerHTML = '🔍 실시간 모니터링 중...';
                     }
                 }, 3000);
             }
        }

                 // 아두이노 연결 (시리얼 통신)
         async function connectArduino() {
             try {
                 addSerialLog('🔌 아두이노 연결 시도 중...');
                 updateConnectionStatus('연결 중...', '#FFC107');
                 
                 // 시리얼 포트 요청
                 port = await navigator.serial.requestPort();
                 await port.open({ 
                     baudRate: 9600,
                     dataBits: 8,
                     stopBits: 1,
                     parity: 'none'
                 });
                 
                 // Writer와 Reader 설정
                 writer = port.writable.getWriter();
                 reader = port.readable.getReader();
                 
                 serialConnected = true;
                 updateConnectionStatus('연결됨', '#4CAF50');
                 
                 // UI 업데이트
                 document.getElementById('connectBtn').disabled = true;
                 document.getElementById('disconnectBtn').disabled = false;
                 
                 addSerialLog('✅ 아두이노 연결 성공!');
                 addSerialLog('📡 시리얼 모니터링 시작...');
                 
                 // 시리얼 데이터 읽기 시작
                 startSerialReading();
                 
                 // 연결 확인 명령 전송
                 setTimeout(() => {
                     sendArduinoCommand('STATUS');
                 }, 2000);
                 
             } catch (error) {
                 console.error('아두이노 연결 오류:', error);
                 addSerialLog('❌ 연결 실패: ' + error.message);
                 updateConnectionStatus('연결 실패', '#f44336');
                 serialConnected = false;
             }
         }

         // 아두이노 연결 해제
         async function disconnectArduino() {
             try {
                 addSerialLog('🔌 아두이노 연결 해제 중...');
                 
                 // 읽기 중지
                 if (readLoop) {
                     readLoop = false;
                 }
                 
                 // Reader와 Writer 해제
                 if (reader) {
                     await reader.cancel();
                     await reader.releaseLock();
                     reader = null;
                 }
                 
                 if (writer) {
                     await writer.releaseLock();
                     writer = null;
                 }
                 
                 // 포트 닫기
                 if (port) {
                     await port.close();
                     port = null;
                 }
                 
                 serialConnected = false;
                 updateConnectionStatus('연결 안됨', '#666');
                 
                 // UI 업데이트
                 document.getElementById('connectBtn').disabled = false;
                 document.getElementById('disconnectBtn').disabled = true;
                 
                 addSerialLog('✅ 아두이노 연결 해제 완료');
                 
             } catch (error) {
                 console.error('연결 해제 오류:', error);
                 addSerialLog('❌ 연결 해제 오류: ' + error.message);
             }
         }

         // 시리얼 연결 (기존 함수 - 호환성 유지)
         async function connectSerial() {
             await connectArduino();
         }

                 // 서버 상태 확인
         async function checkServer() {
             document.getElementById('result').innerHTML = '🔍 서버 연결 상태 확인 중...';
             document.getElementById('status').innerHTML = '📡 localhost:5005 연결 테스트';
             
             const endpoints = [
                 'http://localhost:5005/classify',
                 'http://localhost:5005/predict', 
                 'http://127.0.0.1:5005/classify',
                 'http://127.0.0.1:5005/predict'
             ];
             
             let serverFound = false;
             let workingEndpoint = null;
             
             for (const endpoint of endpoints) {
                 try {
                     document.getElementById('status').innerHTML = `🔍 테스트 중: ${endpoint}`;
                     
                     const controller = new AbortController();
                     const timeoutId = setTimeout(() => controller.abort(), 3000);
                     
                     const response = await fetch(endpoint, {
                         method: 'GET',
                         signal: controller.signal,
                         mode: 'cors'
                     });
                     
                     clearTimeout(timeoutId);
                     
                     if (response.status === 200 || response.status === 405) { // GET이 안되면 405 Method Not Allowed
                         serverFound = true;
                         workingEndpoint = endpoint;
                         
                         if (response.status === 405) {
                             document.getElementById('result').innerHTML = 
                                 `✅ 서버 연결 성공!<br>
                                  <small>엔드포인트: ${endpoint}</small><br>
                                  <small>상태: POST 방식 지원 확인됨</small><br>
                                  <small style="color: #4CAF50;">🎯 분류 테스트 버튼으로 실제 테스트 가능</small>`;
                             document.getElementById('status').innerHTML = '✅ 서버가 정상 작동 중 - POST 방식 준비됨';
                         } else {
                             document.getElementById('result').innerHTML = 
                                 `✅ 서버 연결 성공!<br>
                                  <small>엔드포인트: ${endpoint}</small><br>
                                  <small>상태: ${response.status} ${response.statusText}</small>`;
                             document.getElementById('status').innerHTML = '✅ 서버가 정상 작동 중입니다';
                         }
                         break;
                     }
                 } catch (error) {
                     console.log(`${endpoint} 연결 실패:`, error.message);
                     continue;
                 }
             }
             
             if (!serverFound) {
                 document.getElementById('result').innerHTML = 
                     `❌ localhost:5005 서버에 연결할 수 없습니다<br>
                      <small>• 서버가 실행 중인지 확인하세요</small><br>
                      <small>• 포트 5005가 열려있는지 확인하세요</small><br>
                      <small>• CORS 설정이 되어있는지 확인하세요</small>`;
                 document.getElementById('status').innerHTML = '❌ 서버 연결 실패 - 데모 모드로 작동합니다';
             }
         }

         // 서버 디버그 (상세한 요청/응답 정보)
         async function debugServerRequest() {
             document.getElementById('result').innerHTML = '🐛 서버 디버그 모드...';
             document.getElementById('status').innerHTML = '🔍 상세 분석 중...';
             
             // 간단한 텍스트 데이터로 테스트
             const testData = new FormData();
             testData.append('file', new Blob(['test'], { type: 'text/plain' }), 'test.txt');
             
             try {
                 const response = await fetch('http://localhost:5005/classify', {
                     method: 'POST',
                     body: testData
                 });
                 
                 const responseText = await response.text();
                 
                 document.getElementById('result').innerHTML = 
                     `🐛 디버그 정보:<br>
                      <small>상태: ${response.status} ${response.statusText}</small><br>
                      <small>헤더: ${JSON.stringify([...response.headers.entries()])}</small><br>
                      <small>응답: ${responseText}</small><br>
                      <small>Content-Type: ${response.headers.get('content-type')}</small>`;
                 
                 document.getElementById('status').innerHTML = `🐛 디버그 완료 - 상태: ${response.status}`;
                 
             } catch (error) {
                 document.getElementById('result').innerHTML = `🐛 디버그 오류: ${error.message}`;
                 document.getElementById('status').innerHTML = '❌ 디버그 실패';
             }
         }

                  // 서버 POST 방식 테스트 (JSON + base64 방식)
         async function testServerWithImage() {
             document.getElementById('result').innerHTML = '📤 서버 POST 방식 테스트 중...';
             document.getElementById('status').innerHTML = '🎨 테스트 이미지 생성 중...';
             
             // 테스트용 이미지 생성 (100x100 빨간색 사각형)
             const canvas = document.createElement('canvas');
             canvas.width = 100;
             canvas.height = 100;
             const ctx = canvas.getContext('2d');
             ctx.fillStyle = '#FF0000';
             ctx.fillRect(0, 0, 100, 100);
             ctx.fillStyle = '#FFFFFF';
             ctx.font = '12px Arial';
             ctx.fillText('TEST', 35, 55);
             
             const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.8));
             
             document.getElementById('status').innerHTML = '📤 서버로 테스트 이미지 전송 중...';
             
             // Blob을 base64로 변환
             const base64 = await blobToBase64(blob);
             const base64Data = base64.split(',')[1]; // data:image/jpeg;base64, 부분 제거
             
             const requestData = {
                 image: base64Data
             };
             
             try {
                 document.getElementById('status').innerHTML = '📤 JSON 방식으로 전송 중...';
                 
                 const controller = new AbortController();
                 const timeoutId = setTimeout(() => controller.abort(), 15000); // 15초 (AI 모델 로딩 시간 고려)
                 
                 const response = await fetch('http://localhost:5005/classify', {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json'
                     },
                     body: JSON.stringify(requestData),
                     signal: controller.signal,
                     mode: 'cors'
                 });
                 
                 clearTimeout(timeoutId);
                 
                 if (response.ok) {
                     const result = await response.json();
                     
                     document.getElementById('result').innerHTML = 
                         `✅ 서버 POST 테스트 성공!<br>
                          <small>Trash-Net 모델 응답:</small><br>
                          <small>${JSON.stringify(result, null, 2)}</small><br>
                          <small style="color: #4CAF50;">🎯 AI 분류 서버가 정상 작동합니다!</small>`;
                     document.getElementById('status').innerHTML = '✅ Trash-Net 모델 테스트 성공';
                     return;
                 } else {
                     const errorText = await response.text();
                     document.getElementById('result').innerHTML = 
                         `❌ 서버 응답 오류: ${response.status}<br>
                          <small>${errorText}</small>`;
                     document.getElementById('status').innerHTML = `❌ ${response.status} ${response.statusText}`;
                 }
             } catch (error) {
                 document.getElementById('result').innerHTML = 
                     `❌ 연결 오류: ${error.message}<br>
                      <small>서버가 실행 중인지 확인하세요</small>`;
                 document.getElementById('status').innerHTML = '❌ 서버 연결 실패';
             }
         }

         // 분류 테스트 (수동)
         async function testClassification() {
             const video = document.getElementById('video');
             if (!video || video.videoWidth === 0) {
                 document.getElementById('result').innerHTML = '❌ 카메라를 먼저 시작해주세요';
                 return;
             }
             
             document.getElementById('result').innerHTML = '🧪 수동 분류 테스트 중...';
             document.getElementById('status').innerHTML = '📸 이미지 캡처 중...';
             
             // 현재 프레임 캡처
             const canvas = document.createElement('canvas');
             canvas.width = video.videoWidth;
             canvas.height = video.videoHeight;
             const ctx = canvas.getContext('2d');
             ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
             
             // 전처리 적용
             const optimizedCanvas = preprocessImage(canvas);
             
             const blob = await new Promise(resolve => optimizedCanvas.toBlob(resolve, 'image/jpeg', 0.8));
             
             // 분류 시도
             await classifyImage(blob);
         }

                                       // 이미지 분류 함수 (공통)
           async function classifyImage(blob) {
               try {
                   // Blob을 base64로 변환
                   const base64 = await blobToBase64(blob);
                   const base64Data = base64.split(',')[1]; // data:image/jpeg;base64, 부분 제거
                   
                   const requestData = {
                       image: base64Data
                   };
                   
                   // 서버 연결 진단
                   document.getElementById('status').innerHTML = '🔍 서버 연결 진단 중...';
                   
                   // 로컬 서버 5005 포트 엔드포인트 시도
                   const endpoints = [
                       'http://localhost:5005/classify',
                       'http://127.0.0.1:5005/classify'
                   ];
                   let success = false;
                   let result = null;
                   
                   for (const endpoint of endpoints) {
                       try {
                           document.getElementById('status').innerHTML = `🔍 서버 연결 시도: ${endpoint}`;
                           
                           // fetch에 타임아웃 추가
                           const controller = new AbortController();
                           const timeoutId = setTimeout(() => controller.abort(), 10000); // 10초 타임아웃 (AI 처리 시간 고려)
                           
                           const response = await fetch(endpoint, {
                               method: 'POST',
                               headers: {
                                   'Content-Type': 'application/json'
                               },
                               body: JSON.stringify(requestData),
                               signal: controller.signal,
                               mode: 'cors'
                           });
                           
                           clearTimeout(timeoutId);
                           
                           if (response.ok) {
                               result = await response.json();
                               success = true;
                               document.getElementById('status').innerHTML = `✅ 서버 연결 성공: ${endpoint}`;
                               break;
                           } else {
                               console.log(`${endpoint} 실패: ${response.status} ${response.statusText}`);
                               document.getElementById('status').innerHTML = `❌ ${endpoint}: ${response.status} ${response.statusText}`;
                               const errorText = await response.text();
                               console.log('서버 오류 응답:', errorText);
                           }
                       } catch (error) {
                           console.log(`${endpoint} 연결 실패:`, error.message);
                           document.getElementById('status').innerHTML = `❌ ${endpoint}: ${error.message}`;
                           await new Promise(resolve => setTimeout(resolve, 300)); // 0.3초 대기
                           continue;
                       }
                   }
                  
                                     if (success && result) {
                       // Trash-Net 모델 응답 처리 (배열 형태)
                       let label = '알 수 없음';
                       let confidence = 0;
                       
                                              if (Array.isArray(result) && result.length > 0) {
                           // 가장 높은 확률의 결과 선택
                           const topResult = result[0];
                           label = topResult.label || '알 수 없음';
                           confidence = topResult.score || 0;
                       } else if (result.label) {
                           // 단일 객체 응답 처리
                           label = result.label;
                           confidence = result.confidence || result.score || 0;
                       }
                       
                       // 영어 라벨을 한국어로 통합 매핑
                       let unified = '알 수 없음';
                       if (label === 'plastic') unified = '플라스틱';
                       else if (label === 'paper' || label === 'cardboard') unified = '종이';
                       else if (label === 'metal') unified = '캔';
                       else if (label === 'glass' || label === 'trash') unified = '비닐';
                       else unified = '비닐'; // 기타 모든 경우
                       
                       document.getElementById('result').innerHTML = 
                           `🎯 분류 결과: <span style="color: #4CAF50">${unified}</span><br>
                            <small>원본: ${label} | 신뢰도: ${(confidence * 100).toFixed(1)}%</small>`;
                      
                      document.getElementById('status').innerHTML = '📤 결과 전송 중...';
                      
                                             // 시리얼 전송 (한국어 통합 라벨 사용)
                       if (writer && unified !== '알 수 없음') {
                           await sendToSerial(unified);
                           document.getElementById('status').innerHTML = '✅ 분류 완료';
                       } else {
                           document.getElementById('status').innerHTML = '⚠️ 시리얼 미연결';
                       }
                      
                      return { label, confidence };
                  } else {
                      // 서버가 없으면 데모 모드로 실행
                      throw new Error('모든 서버 엔드포인트 연결 실패');
                  }
              } catch (error) {
                  console.log('분류 함수 오류:', error.message);
                  
                  // 모든 오류 상황에서 데모 모드로 전환
                  document.getElementById('status').innerHTML = '🔄 데모 모드로 전환 중...';
                  
                  await new Promise(resolve => setTimeout(resolve, 1000));
                  
                                   const demoLabels = ['plastic', 'paper', 'cardboard', 'glass', 'metal', 'trash'];
                 const randomLabel = demoLabels[Math.floor(Math.random() * demoLabels.length)];
                 const randomConfidence = 0.7 + Math.random() * 0.3; // 70-100%
                 
                 // 데모 모드에서도 한국어 매핑 적용
                 let demoUnified = '알 수 없음';
                 if (randomLabel === 'plastic') demoUnified = '플라스틱';
                 else if (randomLabel === 'paper' || randomLabel === 'cardboard') demoUnified = '종이';
                 else if (randomLabel === 'metal') demoUnified = '캔';
                 else if (randomLabel === 'glass' || randomLabel === 'trash') demoUnified = '비닐';
                 else demoUnified = '비닐';
                 
                 document.getElementById('result').innerHTML = 
                     `🎯 분류 결과 (데모): <span style="color: #4CAF50">${demoUnified}</span><br>
                      <small>원본: ${randomLabel} | 신뢰도: ${(randomConfidence * 100).toFixed(1)}%</small><br>
                      <small style="color: #FFC107">⚠️ 분류 서버 미연결 - 데모 모드</small>`;
                 
                 document.getElementById('status').innerHTML = '📤 데모 결과 전송 중...';
                 
                 // 시리얼 전송 (데모 - 한국어 라벨 사용)
                 if (writer) {
                     await sendToSerial(demoUnified);
                     document.getElementById('status').innerHTML = '✅ 데모 분류 완료';
                 } else {
                     document.getElementById('status').innerHTML = '⚠️ 시리얼 미연결';
                 }
                  
                  return { label: randomLabel, confidence: randomConfidence };
              }
          }

         // Blob을 base64로 변환하는 헬퍼 함수
         function blobToBase64(blob) {
             return new Promise((resolve, reject) => {
                 const reader = new FileReader();
                 reader.onload = () => resolve(reader.result);
                 reader.onerror = reject;
                 reader.readAsDataURL(blob);
             });
         }

         // 시리얼 데이터 읽기 시작
         async function startSerialReading() {
             readLoop = true;
             
             try {
                 while (readLoop && reader) {
                     const { value, done } = await reader.read();
                     
                     if (done) {
                         break;
                     }
                     
                     // 바이트 데이터를 문자열로 변환
                     const textDecoder = new TextDecoder();
                     const receivedText = textDecoder.decode(value);
                     
                     // 시리얼 로그에 추가 (수신 데이터)
                     if (receivedText.trim()) {
                         addSerialLog('📨 ' + receivedText.trim(), '#00FFFF');
                     }
                 }
             } catch (error) {
                 if (error.name !== 'AbortError') {
                     console.error('시리얼 읽기 오류:', error);
                     addSerialLog('❌ 읽기 오류: ' + error.message, '#FF6B6B');
                 }
             }
         }

         // 아두이노에 명령 전송
         async function sendArduinoCommand(command) {
             if (!writer || !serialConnected) {
                 addSerialLog('❌ 아두이노가 연결되지 않았습니다', '#FF6B6B');
                 return false;
             }
             
             try {
                 const commandWithNewline = command + '\n';
                 const encoder = new TextEncoder();
                 await writer.write(encoder.encode(commandWithNewline));
                 
                 // 전송 로그 추가
                 addSerialLog('📤 전송: ' + command, '#FFFF00');
                 console.log('아두이노로 전송:', command);
                 
                 return true;
             } catch (error) {
                 console.error('명령 전송 오류:', error);
                 addSerialLog('❌ 전송 실패: ' + error.message, '#FF6B6B');
                 return false;
             }
         }

         // 시리얼 데이터 전송 (기존 함수 - 호환성 유지)
         async function sendToSerial(label) {
             await sendArduinoCommand(label);
         }

         // 시리얼 로그에 메시지 추가
         function addSerialLog(message, color = '#00FF00') {
             const logContainer = document.getElementById('serialLog');
             const timestamp = new Date().toLocaleTimeString();
             
             const logEntry = document.createElement('div');
             logEntry.style.color = color;
             logEntry.style.marginBottom = '2px';
             logEntry.innerHTML = `[${timestamp}] ${message}`;
             
             logContainer.appendChild(logEntry);
             
             // 자동 스크롤 (최신 메시지가 보이도록)
             logContainer.parentElement.scrollTop = logContainer.parentElement.scrollHeight;
             
             // 로그 개수 제한 (성능을 위해 최대 100개)
             if (logContainer.children.length > 100) {
                 logContainer.removeChild(logContainer.firstChild);
             }
         }

         // 연결 상태 업데이트
         function updateConnectionStatus(status, color) {
             const statusElement = document.getElementById('connectionStatus');
             statusElement.textContent = status;
             statusElement.style.color = color;
         }

         // 시리얼 로그 지우기
         function clearSerialLog() {
             document.getElementById('serialLog').innerHTML = '';
             addSerialLog('🗑️ 로그가 지워졌습니다');
         }

         // 테스트 명령 전송
         function sendTestCommand() {
             if (!serialConnected) {
                 addSerialLog('❌ 먼저 아두이노를 연결해주세요', '#FF6B6B');
                 return;
             }
             
             const testCommands = ['STATUS', 'HOME', 'SERVO'];
             const randomCommand = testCommands[Math.floor(Math.random() * testCommands.length)];
             
             addSerialLog('🧪 테스트 명령: ' + randomCommand, '#FFC107');
             sendArduinoCommand(randomCommand);
         }

         // 수동 명령 전송
         function sendManualCommand() {
             const commandInput = document.getElementById('manualCommand');
             const command = commandInput.value.trim().toUpperCase();
             
             if (!command) {
                 addSerialLog('❌ 명령어를 입력해주세요', '#FF6B6B');
                 return;
             }
             
             if (!serialConnected) {
                 addSerialLog('❌ 먼저 아두이노를 연결해주세요', '#FF6B6B');
                 return;
             }
             
             sendArduinoCommand(command);
             commandInput.value = ''; // 입력창 비우기
         }

         // Enter 키로 명령 전송
         document.addEventListener('DOMContentLoaded', function() {
             const commandInput = document.getElementById('manualCommand');
             if (commandInput) {
                 commandInput.addEventListener('keypress', function(e) {
                     if (e.key === 'Enter') {
                         sendManualCommand();
                     }
                 });
             }
         });

                 // 정리 함수
         window.addEventListener('beforeunload', async () => {
             // 시리얼 연결 정리
             if (serialConnected) {
                 try {
                     await disconnectArduino();
                 } catch (error) {
                     console.error('정리 중 오류:', error);
                 }
             }
             
             // 카메라 스트림 정리
             if (currentStream) {
                 currentStream.getTracks().forEach(track => track.stop());
             }
         });

        // 자동 시작 (선택사항)
        window.addEventListener('load', () => {
            setTimeout(() => {
                updateCameraList();
            }, 1000);
        });
    </script>
</body>
</html> 