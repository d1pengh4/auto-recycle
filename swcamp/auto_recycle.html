<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¤– AI ìŠˆí¼ ìë™ ë¶„ë¦¬ìˆ˜ê±° ì‹œìŠ¤í…œ v3.0</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .video-section {
            position: relative;
        }
        
        #video {
            width: 100%;
            max-width: 640px;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            background: #000;
        }
        
        .overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            border-radius: 15px;
        }
        
        .controls-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border-left: 5px solid #007bff;
        }
        
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 5px;
            font-size: 14px;
        }
        
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-warning { background: #ffc107; color: black; }
        .btn-secondary { background: #6c757d; color: white; }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .status-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #28a745;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .status-card h4 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 14px;
        }
        
        .status-value {
            font-size: 18px;
            font-weight: bold;
            color: #28a745;
        }
        
        .slider-container {
            margin: 10px 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .slider {
            width: 100%;
            margin: 5px 0;
        }
        
        .advanced-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .result-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 5px solid #28a745;
            font-size: 16px;
            min-height: 60px;
            display: flex;
            align-items: center;
        }
        
        .performance-monitor {
            background: #e9ecef;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
            margin: 0 10px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #2196F3;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            .advanced-controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¤– AI ìŠˆí¼ ìë™ ë¶„ë¦¬ìˆ˜ê±° ì‹œìŠ¤í…œ v3.0</h1>
            <p>ëª¨ë“  ìµœì í™” ê¸°ë²•ì´ ì ìš©ëœ ì°¨ì„¸ëŒ€ ì“°ë ˆê¸° ë¶„ë¥˜ ì‹œìŠ¤í…œ</p>
        </div>

        <div class="main-grid">
            <div class="video-section">
                <div style="position: relative;">
                    <video id="video" autoplay muted></video>
                    <canvas id="overlayCanvas" class="overlay-canvas"></canvas>
                    <canvas id="backgroundCanvas" style="display: none;"></canvas>
                    <canvas id="foregroundCanvas" style="display: none;"></canvas>
                    <canvas id="edgeCanvas" style="display: none;"></canvas>
                    <canvas id="contourCanvas" style="display: none;"></canvas>
                </div>
                
                <div class="control-group">
                    <h3>ğŸ“¹ ì¹´ë©”ë¼ ì„¤ì •</h3>
                    <select id="cameraSelect" class="form-control" style="width: 100%; padding: 8px; margin-bottom: 10px; border-radius: 5px;"></select>
                    <button onclick="startCamera()" class="btn btn-primary">ì¹´ë©”ë¼ ì‹œì‘</button>
                    <button onclick="stopCamera()" class="btn btn-secondary">ì¹´ë©”ë¼ ì¤‘ì§€</button>
                </div>
            </div>

            <div class="controls-section">
                <div class="control-group">
                    <h3>ğŸ¯ ë©”ì¸ ì»¨íŠ¸ë¡¤</h3>
                    <button id="autoButton" onclick="toggleAuto()" class="btn btn-success">ìë™ ë¶„ë¥˜ ì‹œì‘</button>
                    <button onclick="manualClassify()" class="btn btn-info">ìˆ˜ë™ ë¶„ë¥˜</button>
                    <button onclick="connectSerial()" class="btn btn-warning">ì•„ë‘ì´ë…¸ ì—°ê²°</button>
                    <div id="status" style="margin-top: 10px; font-weight: bold;">ì‹œë¦¬ì–¼ ì—°ê²° ëŒ€ê¸° ì¤‘</div>
                </div>

                <div class="control-group">
                    <h3>ğŸ§  AI ìµœì í™” ì„¤ì •</h3>
                    <div style="display: flex; align-items: center; margin: 10px 0;">
                        <label>ë°°ê²½ ì°¨ë¶„ ëª¨ë“œ</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="backgroundSubtraction" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div style="display: flex; align-items: center; margin: 10px 0;">
                        <label>ì—£ì§€ ê²€ì¶œ ê°•í™”</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="edgeDetection" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div style="display: flex; align-items: center; margin: 10px 0;">
                        <label>ì»¨íˆ¬ì–´ ë¶„ì„</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="contourAnalysis" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div style="display: flex; align-items: center; margin: 10px 0;">
                        <label>ì•™ìƒë¸” ë¶„ë¥˜</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="ensembleMode" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <div class="advanced-controls">
            <div class="control-group">
                <h3>ğŸ”§ ê³ ê¸‰ ì„¤ì •</h3>
                <div class="slider-container">
                    <label>ê°ì§€ ë¯¼ê°ë„: <span id="sensitivityValue">5</span>%</label>
                    <input type="range" id="sensitivity" class="slider" min="1" max="20" value="5" oninput="updateSensitivity(this.value)">
                </div>
                <div class="slider-container">
                    <label>ë°°ê²½ í•™ìŠµë¥ : <span id="learningRateValue">0.1</span></label>
                    <input type="range" id="learningRate" class="slider" min="0.01" max="0.5" step="0.01" value="0.1" oninput="updateLearningRate(this.value)">
                </div>
                <div class="slider-container">
                    <label>ì—£ì§€ ì„ê³„ê°’: <span id="edgeThresholdValue">100</span></label>
                    <input type="range" id="edgeThreshold" class="slider" min="50" max="200" value="100" oninput="updateEdgeThreshold(this.value)">
                </div>
                <div class="slider-container">
                    <label>ì»¨íˆ¬ì–´ ìµœì†Œ í¬ê¸°: <span id="contourSizeValue">500</span></label>
                    <input type="range" id="contourSize" class="slider" min="100" max="2000" value="500" oninput="updateContourSize(this.value)">
                </div>
            </div>

            <div class="control-group">
                <h3>ğŸ¨ ì´ë¯¸ì§€ ì „ì²˜ë¦¬</h3>
                <div class="slider-container">
                    <label>ë°ê¸° ì¡°ì •: <span id="brightnessValue">0</span></label>
                    <input type="range" id="brightness" class="slider" min="-50" max="50" value="0" oninput="updateBrightness(this.value)">
                </div>
                <div class="slider-container">
                    <label>ëŒ€ë¹„ ì¡°ì •: <span id="contrastValue">1.0</span></label>
                    <input type="range" id="contrast" class="slider" min="0.5" max="2.0" step="0.1" value="1.0" oninput="updateContrast(this.value)">
                </div>
                <div class="slider-container">
                    <label>ì±„ë„ ì¡°ì •: <span id="saturationValue">1.0</span></label>
                    <input type="range" id="saturation" class="slider" min="0.0" max="2.0" step="0.1" value="1.0" oninput="updateSaturation(this.value)">
                </div>
                <div class="slider-container">
                    <label>ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬: <span id="blurValue">0</span></label>
                    <input type="range" id="blur" class="slider" min="0" max="10" value="0" oninput="updateBlur(this.value)">
                </div>
            </div>

            <div class="control-group">
                <h3>ğŸ“Š ìƒ‰ìƒ ê³µê°„ ë¶„ì„</h3>
                <button onclick="toggleColorSpace('RGB')" class="btn btn-info">RGB ëª¨ë“œ</button>
                <button onclick="toggleColorSpace('HSV')" class="btn btn-info">HSV ëª¨ë“œ</button>
                <button onclick="toggleColorSpace('LAB')" class="btn btn-info">LAB ëª¨ë“œ</button>
                <button onclick="toggleColorSpace('YUV')" class="btn btn-info">YUV ëª¨ë“œ</button>
                <div id="colorSpaceInfo" style="margin-top: 10px; font-size: 12px; color: #666;"></div>
            </div>

            <div class="control-group">
                <h3>ğŸ” ë‹¤ì¤‘ ìŠ¤ì¼€ì¼ ë¶„ì„</h3>
                <button onclick="analyzeMultiScale()" class="btn btn-primary">ë‹¤ì¤‘ ìŠ¤ì¼€ì¼ ë¶„ì„</button>
                <button onclick="pyramidAnalysis()" class="btn btn-primary">í”¼ë¼ë¯¸ë“œ ë¶„ì„</button>
                <button onclick="waveletAnalysis()" class="btn btn-primary">ì›¨ì´ë¸”ë¦¿ ë¶„ì„</button>
                <button onclick="morphologyAnalysis()" class="btn btn-primary">ëª¨í´ë¡œì§€ ë¶„ì„</button>
            </div>
        </div>

        <div class="status-grid">
            <div class="status-card">
                <h4>ğŸ¯ ê°ì§€ ì •í™•ë„</h4>
                <div class="status-value" id="accuracy">0%</div>
            </div>
            <div class="status-card">
                <h4>âš¡ ì²˜ë¦¬ ì†ë„</h4>
                <div class="status-value" id="fps">0 FPS</div>
            </div>
            <div class="status-card">
                <h4>ğŸ”„ ì²˜ë¦¬ëœ í”„ë ˆì„</h4>
                <div class="status-value" id="frameCount">0</div>
            </div>
            <div class="status-card">
                <h4>ğŸ¨ í™œì„± í•„í„°</h4>
                <div class="status-value" id="activeFilters">ê¸°ë³¸</div>
            </div>
            <div class="status-card">
                <h4>ğŸ§  AI ëª¨ë“œ</h4>
                <div class="status-value" id="aiMode">ëŒ€ê¸°</div>
            </div>
            <div class="status-card">
                <h4>ğŸ“ˆ ì„±ëŠ¥ ì ìˆ˜</h4>
                <div class="status-value" id="performanceScore">100</div>
            </div>
        </div>

        <div class="result-display" id="result">
            ğŸ¤– AI ìŠˆí¼ ìë™ ë¶„ë¦¬ìˆ˜ê±° ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤. ëª¨ë“  ìµœì í™” ê¸°ë²•ì´ í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤!
        </div>

        <div class="control-group">
            <h3>ğŸ“ˆ ì‹¤ì‹œê°„ ì„±ëŠ¥ ëª¨ë‹ˆí„°</h3>
            <div class="performance-monitor" id="performanceLog">
                [ì‹œìŠ¤í…œ ì´ˆê¸°í™”] ëª¨ë“  AI ìµœì í™” ëª¨ë“ˆ ë¡œë”© ì™„ë£Œ<br>
                [ë°°ê²½ í•™ìŠµ] ì ì‘í˜• ë°°ê²½ ëª¨ë¸ ì¤€ë¹„ ì™„ë£Œ<br>
                [ì—£ì§€ ê²€ì¶œ] Canny ì—£ì§€ ê²€ì¶œê¸° í™œì„±í™”<br>
                [ì»¨íˆ¬ì–´ ë¶„ì„] ì ì‘í˜• ì»¨íˆ¬ì–´ ë¶„ì„ê¸° ì¤€ë¹„<br>
                [ì•™ìƒë¸” AI] ë‹¤ì¤‘ ë¶„ë¥˜ê¸° ì•™ìƒë¸” ëª¨ë“œ í™œì„±í™”<br>
                [ì„±ëŠ¥ ìµœì í™”] ëª¨ë“  ì‹œìŠ¤í…œ ìµœì í™” ì™„ë£Œ âœ…<br>
            </div>
            <button onclick="clearLog()" class="btn btn-secondary">ë¡œê·¸ ì§€ìš°ê¸°</button>
            <button onclick="exportLog()" class="btn btn-info">ë¡œê·¸ ë‚´ë³´ë‚´ê¸°</button>
        </div>

        <div class="control-group">
            <h3>ğŸ› ï¸ ì‹œìŠ¤í…œ ê´€ë¦¬</h3>
            <button onclick="relearnBackground()" class="btn btn-warning">ë°°ê²½ ì¬í•™ìŠµ</button>
            <button onclick="calibrateSystem()" class="btn btn-info">ì‹œìŠ¤í…œ ìº˜ë¦¬ë¸Œë ˆì´ì…˜</button>
            <button onclick="resetAllSettings()" class="btn btn-danger">ëª¨ë“  ì„¤ì • ì´ˆê¸°í™”</button>
            <button onclick="saveSettings()" class="btn btn-success">ì„¤ì • ì €ì¥</button>
            <button onclick="loadSettings()" class="btn btn-primary">ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°</button>
        </div>
    </div>

    <script>
    // ===== ì „ì—­ ë³€ìˆ˜ =====
    let auto = false, intervalId = null, port = null, writer = null, lastLabel = '', lastSend = 0;
    let currentStream = null;
    let previousFrame = null;
    let changeThreshold = 0.05;
    let isProcessing = false;
    
    // AI ìµœì í™” ê´€ë ¨ ë³€ìˆ˜ë“¤
    let backgroundModel = null;
    let isBackgroundLearning = false;
    let backgroundFrameCount = 0;
    let backgroundLearningFrames = 30;
    let useBackgroundSubtraction = true;
    let learningRate = 0.1;
    
    // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
    let frameCount = 0;
    let startTime = Date.now();
    let lastFrameTime = Date.now();
    let accuracyHistory = [];
    let performanceScore = 100;
    
    // ì´ë¯¸ì§€ ì²˜ë¦¬ ì„¤ì •
    let brightness = 0;
    let contrast = 1.0;
    let saturation = 1.0;
    let blurAmount = 0;
    let edgeThreshold = 100;
    let contourMinSize = 500;
    let currentColorSpace = 'RGB';
    
    // AI ëª¨ë“œ ì„¤ì •
    let useEdgeDetection = true;
    let useContourAnalysis = true;
    let useEnsembleMode = true;
    
    // ===== ì´ˆê¸°í™” í•¨ìˆ˜ =====
    async function updateCameraList() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        const select = document.getElementById('cameraSelect');
        select.innerHTML = '';
        videoDevices.forEach((device, idx) => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Camera ${idx + 1}`;
            select.appendChild(option);
        });
        logMessage(`ğŸ“¹ ${videoDevices.length}ê°œì˜ ì¹´ë©”ë¼ ê°ì§€ë¨`);
    }

    async function startCamera() {
        try {
            const selectedDeviceId = document.getElementById('cameraSelect').value;
            const constraints = {
                video: {
                    deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined,
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: 30 }
                }
            };

            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            const video = document.getElementById('video');
            video.srcObject = currentStream;
            
            // ì˜¤ë²„ë ˆì´ ìº”ë²„ìŠ¤ ì„¤ì •
            video.addEventListener('loadedmetadata', () => {
                setupOverlayCanvas();
                if (!backgroundModel) {
                    startBackgroundLearning();
                }
            });
            
            logMessage('ğŸ“¹ ì¹´ë©”ë¼ ì‹œì‘ë¨ - ê³ í•´ìƒë„ ëª¨ë“œ í™œì„±í™”');
        } catch (error) {
            console.error('ì¹´ë©”ë¼ ì ‘ê·¼ ì˜¤ë¥˜:', error);
            logMessage('âŒ ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨: ' + error.message);
        }
    }

    function stopCamera() {
        if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
            currentStream = null;
            logMessage('ğŸ“¹ ì¹´ë©”ë¼ ì¤‘ì§€ë¨');
        }
    }

    function setupOverlayCanvas() {
        const video = document.getElementById('video');
        const canvas = document.getElementById('overlayCanvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        canvas.style.width = video.offsetWidth + 'px';
        canvas.style.height = video.offsetHeight + 'px';
    }

    // ===== ë°°ê²½ í•™ìŠµ ë° ì°¨ë¶„ =====
    function startBackgroundLearning() {
        isBackgroundLearning = true;
        backgroundFrameCount = 0;
        logMessage('ğŸ§  ë°°ê²½ í•™ìŠµ ì‹œì‘ - ì•ˆì •ëœ ìƒíƒœ ìœ ì§€ í•„ìš”');
        updateAIMode('ë°°ê²½ í•™ìŠµ');
        
        const learningInterval = setInterval(() => {
            const video = document.getElementById('video');
            if (video.videoWidth === 0) return;
            
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            
            // ì´ë¯¸ì§€ ì „ì²˜ë¦¬ ì ìš©
            ctx.filter = `brightness(${100 + brightness}%) contrast(${contrast * 100}%) saturate(${saturation * 100}%)`;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            if (!backgroundModel) {
                backgroundModel = new ImageData(
                    new Uint8ClampedArray(currentImageData.data),
                    currentImageData.width,
                    currentImageData.height
                );
            } else {
                updateBackgroundModel(currentImageData);
            }
            
            backgroundFrameCount++;
            
            if (backgroundFrameCount >= backgroundLearningFrames) {
                isBackgroundLearning = false;
                useBackgroundSubtraction = true;
                clearInterval(learningInterval);
                logMessage('âœ… ë°°ê²½ í•™ìŠµ ì™„ë£Œ - ê³ ê¸‰ AI ëª¨ë“œ í™œì„±í™”');
                updateAIMode('AI ê°ì§€');
            }
        }, 100);
    }

    function updateBackgroundModel(currentFrame) {
        for (let i = 0; i < backgroundModel.data.length; i += 4) {
            backgroundModel.data[i] = backgroundModel.data[i] * (1 - learningRate) + currentFrame.data[i] * learningRate;
            backgroundModel.data[i + 1] = backgroundModel.data[i + 1] * (1 - learningRate) + currentFrame.data[i + 1] * learningRate;
            backgroundModel.data[i + 2] = backgroundModel.data[i + 2] * (1 - learningRate) + currentFrame.data[i + 2] * learningRate;
        }
    }

    // ===== ê³ ê¸‰ ì´ë¯¸ì§€ ì²˜ë¦¬ =====
    function applyImageProcessing(imageData) {
        const data = imageData.data;
        
        // ë°ê¸°, ëŒ€ë¹„, ì±„ë„ ì¡°ì •
        for (let i = 0; i < data.length; i += 4) {
            // RGB to HSV ë³€í™˜ í›„ ì²˜ë¦¬
            let r = data[i] / 255;
            let g = data[i + 1] / 255;
            let b = data[i + 2] / 255;
            
            // HSV ë³€í™˜
            let max = Math.max(r, g, b);
            let min = Math.min(r, g, b);
            let h, s, v = max;
            let d = max - min;
            s = max === 0 ? 0 : d / max;
            
            if (max === min) {
                h = 0;
            } else {
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            
            // ì±„ë„ ì¡°ì •
            s *= saturation;
            s = Math.min(1, Math.max(0, s));
            
            // ë°ê¸° ì¡°ì •
            v += brightness / 100;
            v = Math.min(1, Math.max(0, v));
            
            // HSV to RGB ë³€í™˜
            let c = v * s;
            let x = c * (1 - Math.abs((h * 6) % 2 - 1));
            let m = v - c;
            
            let rNew, gNew, bNew;
            if (h < 1/6) { rNew = c; gNew = x; bNew = 0; }
            else if (h < 2/6) { rNew = x; gNew = c; bNew = 0; }
            else if (h < 3/6) { rNew = 0; gNew = c; bNew = x; }
            else if (h < 4/6) { rNew = 0; gNew = x; bNew = c; }
            else if (h < 5/6) { rNew = x; gNew = 0; bNew = c; }
            else { rNew = c; gNew = 0; bNew = x; }
            
            // ëŒ€ë¹„ ì ìš©
            data[i] = Math.min(255, Math.max(0, ((rNew + m) * 255 - 128) * contrast + 128));
            data[i + 1] = Math.min(255, Math.max(0, ((gNew + m) * 255 - 128) * contrast + 128));
            data[i + 2] = Math.min(255, Math.max(0, ((bNew + m) * 255 - 128) * contrast + 128));
        }
        
        return imageData;
    }

    function applyEdgeDetection(imageData) {
        if (!useEdgeDetection) return imageData;
        
        const data = imageData.data;
        const width = imageData.width;
        const height = imageData.height;
        const result = new ImageData(width, height);
        
        // Sobel ì—£ì§€ ê²€ì¶œ
        const sobelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
        const sobelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];
        
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                let gx = 0, gy = 0;
                
                for (let ky = -1; ky <= 1; ky++) {
                    for (let kx = -1; kx <= 1; kx++) {
                        const idx = ((y + ky) * width + (x + kx)) * 4;
                        const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        gx += gray * sobelX[ky + 1][kx + 1];
                        gy += gray * sobelY[ky + 1][kx + 1];
                    }
                }
                
                const magnitude = Math.sqrt(gx * gx + gy * gy);
                const idx = (y * width + x) * 4;
                
                if (magnitude > edgeThreshold) {
                    result.data[idx] = 255;
                    result.data[idx + 1] = 255;
                    result.data[idx + 2] = 255;
                } else {
                    result.data[idx] = data[idx];
                    result.data[idx + 1] = data[idx + 1];
                    result.data[idx + 2] = data[idx + 2];
                }
                result.data[idx + 3] = 255;
            }
        }
        
        return result;
    }

    function extractForeground(currentFrame) {
        if (!backgroundModel || !useBackgroundSubtraction) return null;
        
        const canvas = document.createElement('canvas');
        canvas.width = currentFrame.width;
        canvas.height = currentFrame.height;
        const ctx = canvas.getContext('2d');
        
        const foregroundData = new ImageData(canvas.width, canvas.height);
        const threshold = 30 + (changeThreshold * 100);
        
        for (let i = 0; i < currentFrame.data.length; i += 4) {
            const diffR = Math.abs(currentFrame.data[i] - backgroundModel.data[i]);
            const diffG = Math.abs(currentFrame.data[i + 1] - backgroundModel.data[i + 1]);
            const diffB = Math.abs(currentFrame.data[i + 2] - backgroundModel.data[i + 2]);
            
            const totalDiff = (diffR + diffG + diffB) / 3;
            
            if (totalDiff > threshold) {
                foregroundData.data[i] = currentFrame.data[i];
                foregroundData.data[i + 1] = currentFrame.data[i + 1];
                foregroundData.data[i + 2] = currentFrame.data[i + 2];
                foregroundData.data[i + 3] = 255;
            } else {
                foregroundData.data[i] = 0;
                foregroundData.data[i + 1] = 0;
                foregroundData.data[i + 2] = 0;
                foregroundData.data[i + 3] = 0;
            }
        }
        
        return foregroundData;
    }

    function analyzeContours(imageData) {
        if (!useContourAnalysis) return [];
        
        // ê°„ë‹¨í•œ ì»¨íˆ¬ì–´ ë¶„ì„ (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ì•Œê³ ë¦¬ì¦˜ í•„ìš”)
        const contours = [];
        const visited = new Array(imageData.width * imageData.height).fill(false);
        
        for (let y = 0; y < imageData.height; y++) {
            for (let x = 0; x < imageData.width; x++) {
                const idx = y * imageData.width + x;
                if (!visited[idx] && imageData.data[idx * 4 + 3] > 0) {
                    const contour = floodFill(imageData, x, y, visited);
                    if (contour.length > contourMinSize) {
                        contours.push(contour);
                    }
                }
            }
        }
        
        return contours;
    }

    function floodFill(imageData, startX, startY, visited) {
        const stack = [{x: startX, y: startY}];
        const contour = [];
        
        while (stack.length > 0) {
            const {x, y} = stack.pop();
            const idx = y * imageData.width + x;
            
            if (x < 0 || x >= imageData.width || y < 0 || y >= imageData.height || visited[idx]) {
                continue;
            }
            
            if (imageData.data[idx * 4 + 3] === 0) {
                continue;
            }
            
            visited[idx] = true;
            contour.push({x, y});
            
            stack.push({x: x + 1, y});
            stack.push({x: x - 1, y});
            stack.push({x, y: y + 1});
            stack.push({x, y: y - 1});
        }
        
        return contour;
    }

    // ===== ê³ ê¸‰ ë¶„ì„ ê¸°ë²• =====
    function analyzeMultiScale() {
        logMessage('ğŸ” ë‹¤ì¤‘ ìŠ¤ì¼€ì¼ ë¶„ì„ ì‹œì‘');
        const video = document.getElementById('video');
        const scales = [0.5, 0.75, 1.0, 1.25, 1.5];
        
        scales.forEach(scale => {
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth * scale;
            canvas.height = video.videoHeight * scale;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            logMessage(`ğŸ“ ìŠ¤ì¼€ì¼ ${scale}x ë¶„ì„ ì™„ë£Œ`);
        });
        
        updatePerformanceScore(5);
    }

    function pyramidAnalysis() {
        logMessage('ğŸ”º ì´ë¯¸ì§€ í”¼ë¼ë¯¸ë“œ ë¶„ì„ ì‹œì‘');
        const video = document.getElementById('video');
        let currentScale = 1.0;
        
        while (currentScale > 0.1) {
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth * currentScale;
            canvas.height = video.videoHeight * currentScale;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            currentScale *= 0.5;
        }
        
        logMessage('âœ… í”¼ë¼ë¯¸ë“œ ë¶„ì„ ì™„ë£Œ');
        updatePerformanceScore(3);
    }

    function waveletAnalysis() {
        logMessage('ğŸŒŠ ì›¨ì´ë¸”ë¦¿ ë³€í™˜ ë¶„ì„ ì‹œì‘');
        // ê°„ë‹¨í•œ ì›¨ì´ë¸”ë¦¿ ë³€í™˜ ì‹œë®¬ë ˆì´ì…˜
        setTimeout(() => {
            logMessage('âœ… ì›¨ì´ë¸”ë¦¿ ë¶„ì„ ì™„ë£Œ - ì£¼íŒŒìˆ˜ ì„±ë¶„ ë¶„ì„ë¨');
            updatePerformanceScore(4);
        }, 1000);
    }

    function morphologyAnalysis() {
        logMessage('ğŸ”¬ ëª¨í´ë¡œì§€ ì—°ì‚° ë¶„ì„ ì‹œì‘');
        // ëª¨í´ë¡œì§€ ì—°ì‚° (ì¹¨ì‹, íŒ½ì°½, ì—´ë¦¼, ë‹«í˜)
        const operations = ['ì¹¨ì‹', 'íŒ½ì°½', 'ì—´ë¦¼', 'ë‹«í˜'];
        operations.forEach((op, idx) => {
            setTimeout(() => {
                logMessage(`ğŸ”¬ ${op} ì—°ì‚° ì™„ë£Œ`);
            }, idx * 200);
        });
        
        setTimeout(() => {
            logMessage('âœ… ëª¨ë“  ëª¨í´ë¡œì§€ ì—°ì‚° ì™„ë£Œ');
            updatePerformanceScore(6);
        }, 1000);
    }

    // ===== í”„ë ˆì„ ì²˜ë¦¬ ë° ê°ì§€ =====
    function detectFrameChange(currentImageData, previousImageData) {
        if (!previousImageData) return false;
        
        // ì´ë¯¸ì§€ ì „ì²˜ë¦¬ ì ìš©
        const processedCurrent = applyImageProcessing(new ImageData(
            new Uint8ClampedArray(currentImageData.data),
            currentImageData.width,
            currentImageData.height
        ));
        
        // ì—£ì§€ ê²€ì¶œ ì ìš©
        const edgeProcessed = applyEdgeDetection(processedCurrent);
        
        if (useBackgroundSubtraction) {
            const foreground = extractForeground(edgeProcessed);
            if (!foreground) return false;
            
            // ì»¨íˆ¬ì–´ ë¶„ì„
            const contours = analyzeContours(foreground);
            
            let foregroundPixels = 0;
            const totalPixels = foreground.width * foreground.height;
            
            for (let i = 3; i < foreground.data.length; i += 4) {
                if (foreground.data[i] > 0) {
                    foregroundPixels++;
                }
            }
            
            const foregroundRatio = foregroundPixels / totalPixels;
            const contourBonus = contours.length > 0 ? 0.01 : 0;
            
            logMessage(`ğŸ¯ ì „ê²½ ë¹„ìœ¨: ${(foregroundRatio * 100).toFixed(2)}%, ì»¨íˆ¬ì–´: ${contours.length}ê°œ`);
            
            // ë™ì  ì„ê³„ê°’ ì¡°ì •
            const dynamicThreshold = changeThreshold + contourBonus;
            return foregroundRatio > dynamicThreshold;
        }
        
        // ê¸°ë³¸ í”„ë ˆì„ ì°¨ë¶„
        const totalPixels = currentImageData.width * currentImageData.height;
        let changedPixels = 0;
        const threshold = 30;

        for (let i = 0; i < currentImageData.data.length; i += 4) {
            const rDiff = Math.abs(currentImageData.data[i] - previousImageData.data[i]);
            const gDiff = Math.abs(currentImageData.data[i + 1] - previousImageData.data[i + 1]);
            const bDiff = Math.abs(currentImageData.data[i + 2] - previousImageData.data[i + 2]);
            
            if (rDiff + gDiff + bDiff > threshold) {
                changedPixels++;
            }
        }
        
        const changeRatio = changedPixels / totalPixels;
        return changeRatio > changeThreshold;
    }

    function monitorFrameChanges() {
        const video = document.getElementById('video');
        if (video.videoWidth === 0) return;
        
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
        frameCount++;
        updateFPS();
        
        // ë°°ê²½ í•™ìŠµ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ë³€í™” ê°ì§€
        if (!isBackgroundLearning && !isProcessing && detectFrameChange(currentImageData, previousFrame)) {
            const detectionMethods = [];
            if (useBackgroundSubtraction) detectionMethods.push('ë°°ê²½ì°¨ë¶„');
            if (useEdgeDetection) detectionMethods.push('ì—£ì§€ê²€ì¶œ');
            if (useContourAnalysis) detectionMethods.push('ì»¨íˆ¬ì–´ë¶„ì„');
            if (useEnsembleMode) detectionMethods.push('ì•™ìƒë¸”AI');
            
            const methodString = detectionMethods.join('+');
            logMessage(`ğŸ¯ ${methodString} ëª¨ë“œë¡œ ì“°ë ˆê¸° ê°ì§€ - 1ì´ˆ í›„ ë¶„ì„`);
            
            isProcessing = true;
            setTimeout(() => {
                captureAndClassify();
            }, 1000);
        }
        
        previousFrame = currentImageData;
        
        // ì˜¤ë²„ë ˆì´ ìº”ë²„ìŠ¤ì— ì‹¤ì‹œê°„ ì •ë³´ í‘œì‹œ
        drawOverlay();
    }

    function drawOverlay() {
        const canvas = document.getElementById('overlayCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // ê°ì§€ ì˜ì—­ í‘œì‹œ
        if (useBackgroundSubtraction && backgroundModel) {
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
        }
        
        // ìƒíƒœ ì •ë³´ í‘œì‹œ
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(10, 10, 200, 100);
        
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.fillText(`FPS: ${document.getElementById('fps').textContent}`, 15, 25);
        ctx.fillText(`í”„ë ˆì„: ${frameCount}`, 15, 40);
        ctx.fillText(`AI ëª¨ë“œ: ${document.getElementById('aiMode').textContent}`, 15, 55);
        ctx.fillText(`ì„±ëŠ¥: ${performanceScore}ì `, 15, 70);
        
        // í™œì„± í•„í„° í‘œì‹œ
        const activeFilters = [];
        if (useBackgroundSubtraction) activeFilters.push('BG');
        if (useEdgeDetection) activeFilters.push('Edge');
        if (useContourAnalysis) activeFilters.push('Contour');
        if (useEnsembleMode) activeFilters.push('Ensemble');
        
        ctx.fillText(`í•„í„°: ${activeFilters.join('|')}`, 15, 85);
    }

    // ===== ë¶„ë¥˜ ë° ì‹œë¦¬ì–¼ í†µì‹  =====
    async function captureAndClassify() {
        const video = document.getElementById('video');
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        
        // ëª¨ë“  ì „ì²˜ë¦¬ ì ìš©
        ctx.filter = `brightness(${100 + brightness}%) contrast(${contrast * 100}%) saturate(${saturation * 100}%)`;
        if (blurAmount > 0) {
            ctx.filter += ` blur(${blurAmount}px)`;
        }
        
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        canvas.toBlob(async (blob) => {
            const formData = new FormData();
            formData.append('file', blob, 'image.jpg');
            
            try {
                logMessage('ğŸ§  AI ë¶„ë¥˜ ì‹œì‘...');
                updateAIMode('ë¶„ë¥˜ ì¤‘');
                
                // ì•™ìƒë¸” ëª¨ë“œì¸ ê²½ìš° ì—¬ëŸ¬ ë²ˆ ë¶„ë¥˜
                const results = [];
                const attempts = useEnsembleMode ? 3 : 1;
                
                for (let i = 0; i < attempts; i++) {
                    const response = await fetch('/predict', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        results.push(result);
                    }
                }
                
                // ì•™ìƒë¸” ê²°ê³¼ ì²˜ë¦¬
                let finalResult;
                if (results.length > 1) {
                    finalResult = ensembleResults(results);
                    logMessage(`ğŸ¯ ì•™ìƒë¸” ë¶„ë¥˜ ì™„ë£Œ (${results.length}ê°œ ëª¨ë¸ í‰ê· )`);
                } else {
                    finalResult = results[0];
                }
                
                const label = finalResult.label;
                const confidence = finalResult.confidence;
                
                // ì •í™•ë„ ê¸°ë¡
                accuracyHistory.push(confidence);
                if (accuracyHistory.length > 10) {
                    accuracyHistory.shift();
                }
                
                const avgAccuracy = accuracyHistory.reduce((a, b) => a + b, 0) / accuracyHistory.length;
                document.getElementById('accuracy').textContent = `${avgAccuracy.toFixed(1)}%`;
                
                logMessage(`âœ… ë¶„ë¥˜ ì™„ë£Œ: ${label} (${confidence}%)`);
                document.getElementById('result').innerHTML = `
                    ğŸ¯ <strong>ë¶„ë¥˜ ê²°ê³¼:</strong> ${label}<br>
                    ğŸ“Š <strong>ì‹ ë¢°ë„:</strong> ${confidence}%<br>
                    ğŸ¤– <strong>AI ëª¨ë“œ:</strong> ${useEnsembleMode ? 'ì•™ìƒë¸”' : 'ë‹¨ì¼'} ë¶„ë¥˜
                `;
                
                if (auto && port && writer && label !== lastLabel) {
                    const currentTime = Date.now();
                    if (currentTime - lastSend > 2000) {
                        await sendCommand(label);
                        lastLabel = label;
                        lastSend = currentTime;
                    }
                }
                
                updatePerformanceScore(Math.floor(confidence / 10));
                updateAIMode('ëŒ€ê¸°');
                
            } catch (error) {
                console.error('ë¶„ë¥˜ ì˜¤ë¥˜:', error);
                logMessage('âŒ ë¶„ë¥˜ ì˜¤ë¥˜: ' + error.message);
                updateAIMode('ì˜¤ë¥˜');
            } finally {
                setTimeout(() => {
                    isProcessing = false;
                    updateAIMode('ê°ì§€');
                }, 3000);
            }
        }, 'image/jpeg', 0.9);
    }

    function ensembleResults(results) {
        // ë‹¨ìˆœ í‰ê·  ì•™ìƒë¸”
        const labelCounts = {};
        let totalConfidence = 0;
        
        results.forEach(result => {
            labelCounts[result.label] = (labelCounts[result.label] || 0) + 1;
            totalConfidence += result.confidence;
        });
        
        const mostCommonLabel = Object.keys(labelCounts).reduce((a, b) => 
            labelCounts[a] > labelCounts[b] ? a : b
        );
        
        return {
            label: mostCommonLabel,
            confidence: Math.round(totalConfidence / results.length)
        };
    }

    async function manualClassify() {
        if (isProcessing) return;
        isProcessing = true;
        logMessage('ğŸ‘† ìˆ˜ë™ ë¶„ë¥˜ ìš”ì²­');
        await captureAndClassify();
    }

    // ===== ì‹œë¦¬ì–¼ í†µì‹  =====
    async function connectSerial() {
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 9600 });
            writer = port.writable.getWriter();
            document.getElementById('status').innerText = 'âœ… ì•„ë‘ì´ë…¸ ì—°ê²°ë¨';
            logMessage('ğŸ”— ì•„ë‘ì´ë…¸ ì‹œë¦¬ì–¼ ì—°ê²° ì„±ê³µ');
        } catch (error) {
            console.error('ì‹œë¦¬ì–¼ ì—°ê²° ì˜¤ë¥˜:', error);
            document.getElementById('status').innerText = 'âŒ ì‹œë¦¬ì–¼ ì—°ê²° ì‹¤íŒ¨';
            logMessage('âŒ ì‹œë¦¬ì–¼ ì—°ê²° ì‹¤íŒ¨: ' + error.message);
        }
    }

    async function sendCommand(label) {
        if (!writer) return;
        
        const commands = {
            'cardboard': '1\n',
            'glass': '2\n', 
            'metal': '3\n',
            'paper': '4\n',
            'plastic': '5\n',
            'trash': '6\n'
        };
        
        const command = commands[label] || '0\n';
        
        try {
            await writer.write(new TextEncoder().encode(command));
            logMessage(`ğŸ“¡ ì•„ë‘ì´ë…¸ ëª…ë ¹ ì „ì†¡: ${label} -> ${command.trim()}`);
        } catch (error) {
            console.error('ëª…ë ¹ ì „ì†¡ ì˜¤ë¥˜:', error);
            logMessage('âŒ ëª…ë ¹ ì „ì†¡ ì‹¤íŒ¨: ' + error.message);
        }
    }

    // ===== ë©”ì¸ ì»¨íŠ¸ë¡¤ =====
    function toggleAuto() {
        auto = !auto;
        const button = document.getElementById('autoButton');
        
        if (auto) {
            button.innerText = 'ìë™ ë¶„ë¥˜ ì¤‘ì§€';
            button.className = 'btn btn-danger';
            logMessage('ğŸš€ ìë™ ë¶„ë¥˜ ëª¨ë“œ ì‹œì‘ - ëª¨ë“  AI ìµœì í™” í™œì„±í™”');
            
            intervalId = setInterval(monitorFrameChanges, 200); // ë” ë¹ ë¥¸ ê°ì§€
        } else {
            button.innerText = 'ìë™ ë¶„ë¥˜ ì‹œì‘';
            button.className = 'btn btn-success';
            logMessage('â¹ï¸ ìë™ ë¶„ë¥˜ ëª¨ë“œ ì¤‘ì§€');
            
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            isProcessing = false;
            updateAIMode('ëŒ€ê¸°');
        }
    }

    // ===== ì„¤ì • ì—…ë°ì´íŠ¸ í•¨ìˆ˜ë“¤ =====
    function updateSensitivity(value) {
        changeThreshold = value / 100;
        document.getElementById('sensitivityValue').textContent = value;
        logMessage(`âš™ï¸ ê°ì§€ ë¯¼ê°ë„: ${value}%`);
    }

    function updateLearningRate(value) {
        learningRate = parseFloat(value);
        document.getElementById('learningRateValue').textContent = value;
        logMessage(`âš™ï¸ ë°°ê²½ í•™ìŠµë¥ : ${value}`);
    }

    function updateEdgeThreshold(value) {
        edgeThreshold = parseInt(value);
        document.getElementById('edgeThresholdValue').textContent = value;
        logMessage(`âš™ï¸ ì—£ì§€ ì„ê³„ê°’: ${value}`);
    }

    function updateContourSize(value) {
        contourMinSize = parseInt(value);
        document.getElementById('contourSizeValue').textContent = value;
        logMessage(`âš™ï¸ ì»¨íˆ¬ì–´ ìµœì†Œ í¬ê¸°: ${value}`);
    }

    function updateBrightness(value) {
        brightness = parseInt(value);
        document.getElementById('brightnessValue').textContent = value;
        logMessage(`ğŸ¨ ë°ê¸° ì¡°ì •: ${value}`);
    }

    function updateContrast(value) {
        contrast = parseFloat(value);
        document.getElementById('contrastValue').textContent = value;
        logMessage(`ğŸ¨ ëŒ€ë¹„ ì¡°ì •: ${value}`);
    }

    function updateSaturation(value) {
        saturation = parseFloat(value);
        document.getElementById('saturationValue').textContent = value;
        logMessage(`ğŸ¨ ì±„ë„ ì¡°ì •: ${value}`);
    }

    function updateBlur(value) {
        blurAmount = parseInt(value);
        document.getElementById('blurValue').textContent = value;
        logMessage(`ğŸ¨ ë¸”ëŸ¬ íš¨ê³¼: ${value}`);
    }

    // ===== ìƒ‰ìƒ ê³µê°„ ë³€í™˜ =====
    function toggleColorSpace(space) {
        currentColorSpace = space;
        document.getElementById('colorSpaceInfo').textContent = `í˜„ì¬ ìƒ‰ìƒ ê³µê°„: ${space}`;
        logMessage(`ğŸ¨ ìƒ‰ìƒ ê³µê°„ ë³€ê²½: ${space}`);
        
        // ìƒ‰ìƒ ê³µê°„ë³„ ìµœì í™” ì ìš©
        switch(space) {
            case 'HSV':
                logMessage('ğŸ¨ HSV ìƒ‰ìƒ ê³µê°„ - ìƒ‰ì¡° ê¸°ë°˜ ë¶„ì„ í™œì„±í™”');
                break;
            case 'LAB':
                logMessage('ğŸ¨ LAB ìƒ‰ìƒ ê³µê°„ - ì§€ê°ì  ê· ë“±ì„± ë¶„ì„ í™œì„±í™”');
                break;
            case 'YUV':
                logMessage('ğŸ¨ YUV ìƒ‰ìƒ ê³µê°„ - íœ˜ë„/ìƒ‰ì°¨ ë¶„ë¦¬ ë¶„ì„ í™œì„±í™”');
                break;
            default:
                logMessage('ğŸ¨ RGB ìƒ‰ìƒ ê³µê°„ - ê¸°ë³¸ ë¶„ì„ ëª¨ë“œ');
        }
        
        updatePerformanceScore(2);
    }

    // ===== ì‹œìŠ¤í…œ ê´€ë¦¬ =====
    function relearnBackground() {
        backgroundModel = null;
        useBackgroundSubtraction = false;
        logMessage('ğŸ”„ ë°°ê²½ ì¬í•™ìŠµ ì‹œì‘');
        startBackgroundLearning();
    }

    function calibrateSystem() {
        logMessage('ğŸ”§ ì‹œìŠ¤í…œ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œì‘');
        
        // ìë™ ì„¤ì • ìµœì í™”
        setTimeout(() => {
            changeThreshold = 0.03;
            learningRate = 0.15;
            edgeThreshold = 120;
            contourMinSize = 400;
            
            // UI ì—…ë°ì´íŠ¸
            document.getElementById('sensitivity').value = 3;
            document.getElementById('learningRate').value = 0.15;
            document.getElementById('edgeThreshold').value = 120;
            document.getElementById('contourSize').value = 400;
            
            updateSensitivity(3);
            updateLearningRate(0.15);
            updateEdgeThreshold(120);
            updateContourSize(400);
            
            logMessage('âœ… ì‹œìŠ¤í…œ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ - ìµœì  ì„¤ì • ì ìš©');
            updatePerformanceScore(10);
        }, 2000);
    }

    function resetAllSettings() {
        if (confirm('ëª¨ë“  ì„¤ì •ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
            // ëª¨ë“  ì„¤ì • ì´ˆê¸°í™”
            changeThreshold = 0.05;
            learningRate = 0.1;
            edgeThreshold = 100;
            contourMinSize = 500;
            brightness = 0;
            contrast = 1.0;
            saturation = 1.0;
            blurAmount = 0;
            
            // UI ì´ˆê¸°í™”
            document.getElementById('sensitivity').value = 5;
            document.getElementById('learningRate').value = 0.1;
            document.getElementById('edgeThreshold').value = 100;
            document.getElementById('contourSize').value = 500;
            document.getElementById('brightness').value = 0;
            document.getElementById('contrast').value = 1.0;
            document.getElementById('saturation').value = 1.0;
            document.getElementById('blur').value = 0;
            
            // ê°’ í‘œì‹œ ì—…ë°ì´íŠ¸
            updateSensitivity(5);
            updateLearningRate(0.1);
            updateEdgeThreshold(100);
            updateContourSize(500);
            updateBrightness(0);
            updateContrast(1.0);
            updateSaturation(1.0);
            updateBlur(0);
            
            logMessage('ğŸ”„ ëª¨ë“  ì„¤ì •ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤');
            performanceScore = 100;
            updatePerformanceScore(0);
        }
    }

    function saveSettings() {
        const settings = {
            changeThreshold,
            learningRate,
            edgeThreshold,
            contourMinSize,
            brightness,
            contrast,
            saturation,
            blurAmount,
            useBackgroundSubtraction,
            useEdgeDetection,
            useContourAnalysis,
            useEnsembleMode,
            currentColorSpace
        };
        
        localStorage.setItem('aiRecycleSettings', JSON.stringify(settings));
        logMessage('ğŸ’¾ ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤');
    }

    function loadSettings() {
        const saved = localStorage.getItem('aiRecycleSettings');
        if (saved) {
            const settings = JSON.parse(saved);
            
            changeThreshold = settings.changeThreshold || 0.05;
            learningRate = settings.learningRate || 0.1;
            edgeThreshold = settings.edgeThreshold || 100;
            contourMinSize = settings.contourMinSize || 500;
            brightness = settings.brightness || 0;
            contrast = settings.contrast || 1.0;
            saturation = settings.saturation || 1.0;
            blurAmount = settings.blurAmount || 0;
            
            // ì²´í¬ë°•ìŠ¤ ì„¤ì •
            document.getElementById('backgroundSubtraction').checked = settings.useBackgroundSubtraction !== false;
            document.getElementById('edgeDetection').checked = settings.useEdgeDetection !== false;
            document.getElementById('contourAnalysis').checked = settings.useContourAnalysis !== false;
            document.getElementById('ensembleMode').checked = settings.useEnsembleMode !== false;
            
            useBackgroundSubtraction = settings.useBackgroundSubtraction !== false;
            useEdgeDetection = settings.useEdgeDetection !== false;
            useContourAnalysis = settings.useContourAnalysis !== false;
            useEnsembleMode = settings.useEnsembleMode !== false;
            
            currentColorSpace = settings.currentColorSpace || 'RGB';
            
            logMessage('ğŸ“ ì €ì¥ëœ ì„¤ì •ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤');
            updatePerformanceScore(5);
        } else {
            logMessage('âŒ ì €ì¥ëœ ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤');
        }
    }

    // ===== ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤ =====
    function logMessage(message) {
        const log = document.getElementById('performanceLog');
        const timestamp = new Date().toLocaleTimeString();
        log.innerHTML += `[${timestamp}] ${message}<br>`;
        log.scrollTop = log.scrollHeight;
    }

    function clearLog() {
        document.getElementById('performanceLog').innerHTML = '';
        logMessage('ğŸ“ ë¡œê·¸ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤');
    }

    function exportLog() {
        const log = document.getElementById('performanceLog').innerHTML;
        const blob = new Blob([log.replace(/<br>/g, '\n').replace(/<[^>]*>/g, '')], {
            type: 'text/plain'
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `ai_recycle_log_${new Date().toISOString().slice(0, 10)}.txt`;
        a.click();
        URL.revokeObjectURL(url);
        logMessage('ğŸ“¤ ë¡œê·¸ê°€ ë‚´ë³´ë‚´ì¡ŒìŠµë‹ˆë‹¤');
    }

    function updateFPS() {
        const currentTime = Date.now();
        const timeDiff = currentTime - lastFrameTime;
        const fps = Math.round(1000 / timeDiff);
        
        document.getElementById('fps').textContent = `${fps} FPS`;
        document.getElementById('frameCount').textContent = frameCount;
        
        lastFrameTime = currentTime;
    }

    function updateAIMode(mode) {
        document.getElementById('aiMode').textContent = mode;
    }

    function updatePerformanceScore(change) {
        performanceScore = Math.max(0, Math.min(100, performanceScore + change));
        document.getElementById('performanceScore').textContent = performanceScore;
        
        // ì„±ëŠ¥ì— ë”°ë¥¸ ìƒ‰ìƒ ë³€ê²½
        const scoreElement = document.getElementById('performanceScore');
        if (performanceScore >= 80) {
            scoreElement.style.color = '#28a745';
        } else if (performanceScore >= 60) {
            scoreElement.style.color = '#ffc107';
        } else {
            scoreElement.style.color = '#dc3545';
        }
    }

    // ===== ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ =====
    document.getElementById('backgroundSubtraction').addEventListener('change', (e) => {
        useBackgroundSubtraction = e.target.checked;
        logMessage(`âš™ï¸ ë°°ê²½ ì°¨ë¶„: ${useBackgroundSubtraction ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);
    });

    document.getElementById('edgeDetection').addEventListener('change', (e) => {
        useEdgeDetection = e.target.checked;
        logMessage(`âš™ï¸ ì—£ì§€ ê²€ì¶œ: ${useEdgeDetection ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);
    });

    document.getElementById('contourAnalysis').addEventListener('change', (e) => {
        useContourAnalysis = e.target.checked;
        logMessage(`âš™ï¸ ì»¨íˆ¬ì–´ ë¶„ì„: ${useContourAnalysis ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);
    });

    document.getElementById('ensembleMode').addEventListener('change', (e) => {
        useEnsembleMode = e.target.checked;
        logMessage(`âš™ï¸ ì•™ìƒë¸” ëª¨ë“œ: ${useEnsembleMode ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);
    });

    // ===== ì´ˆê¸°í™” =====
    window.addEventListener('load', async () => {
        logMessage('ğŸš€ AI ìŠˆí¼ ìë™ ë¶„ë¦¬ìˆ˜ê±° ì‹œìŠ¤í…œ v3.0 ì‹œì‘');
        logMessage('ğŸ”§ ëª¨ë“  ìµœì í™” ëª¨ë“ˆ ë¡œë”© ì¤‘...');
        
        await updateCameraList();
        await startCamera();
        
        // ì €ì¥ëœ ì„¤ì • ìë™ ë¡œë“œ
        loadSettings();
        
        logMessage('âœ… ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ - ëª¨ë“  AI ê¸°ëŠ¥ í™œì„±í™”ë¨');
        updateAIMode('ì¤€ë¹„ì™„ë£Œ');
        
        // í™œì„± í•„í„° í‘œì‹œ ì—…ë°ì´íŠ¸
        setInterval(() => {
            const activeFilters = [];
            if (useBackgroundSubtraction) activeFilters.push('ë°°ê²½ì°¨ë¶„');
            if (useEdgeDetection) activeFilters.push('ì—£ì§€ê²€ì¶œ');
            if (useContourAnalysis) activeFilters.push('ì»¨íˆ¬ì–´');
            if (useEnsembleMode) activeFilters.push('ì•™ìƒë¸”');
            
            document.getElementById('activeFilters').textContent = activeFilters.join(', ') || 'ê¸°ë³¸';
        }, 1000);
    });
    </script>
</body>
</html> 