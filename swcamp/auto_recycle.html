<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ìë™ ë¶„ë¦¬ìˆ˜ê±° ê¸°ê³„ (Auto Recycle Machine)</title>
    <style>
        body { font-family: Arial, sans-serif; background: #f4f4f4; margin: 0; padding: 0; }
        .container { max-width: 500px; margin: 50px auto; background: #fff; padding: 30px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        h1 { text-align: center; }
        #result { margin-top: 20px; font-size: 1.2em; text-align: center; }
        input[type="file"] { display: block; margin: 20px auto; }
        button { display: block; margin: 0 auto; padding: 10px 20px; font-size: 1em; }
        #video { display: block; margin: 0 auto; border-radius: 10px; background: #222; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ìë™ ë¶„ë¦¬ìˆ˜ê±° ê¸°ê³„<br><small>Auto Recycle Machine</small></h1>
        <select id="cameraSelect" style="display:block; margin:10px auto; padding:5px 10px;"></select>
        <video id="video" width="320" height="240" autoplay playsinline></video>
        <div style="margin:10px 0; text-align:center;">
            <button onclick="toggleAuto()" id="autoBtn">ìë™ ë¶„ë¥˜ ì‹œì‘</button>
            <button onclick="connectSerial()">ì•„ë‘ì´ë…¸ ì—°ê²°</button>
        </div>
        <div id="result">ë¶„ë¥˜ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</div>
    </div>
    <script>
    let auto = false, intervalId = null, port = null, writer = null, lastLabel = '', lastSend = 0;
    let currentStream = null;
    let previousFrame = null; // ì´ì „ í”„ë ˆì„ì„ ì €ì¥í•  ë³€ìˆ˜
    let changeThreshold = 0.05; // ë³€í™” ê°ì§€ ì„ê³„ê°’ (5%)
    let isProcessing = false; // í˜„ì¬ ë¶„ë¥˜ ì²˜ë¦¬ ì¤‘ì¸ì§€ í™•ì¸
    
    // ë°°ê²½ ìµœì í™” ê´€ë ¨ ë³€ìˆ˜ë“¤
    let backgroundModel = null; // ë°°ê²½ ëª¨ë¸
    let isBackgroundLearning = false; // ë°°ê²½ í•™ìŠµ ì¤‘ì¸ì§€ í™•ì¸
    let backgroundFrameCount = 0; // ë°°ê²½ í•™ìŠµìš© í”„ë ˆì„ ì¹´ìš´íŠ¸
    let backgroundLearningFrames = 30; // ë°°ê²½ í•™ìŠµì— í•„ìš”í•œ í”„ë ˆì„ ìˆ˜
    let useBackgroundSubtraction = false; // ë°°ê²½ ì°¨ë¶„ ì‚¬ìš© ì—¬ë¶€

    // ì¹´ë©”ë¼ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ë° ì„ íƒ
    async function updateCameraList() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        const select = document.getElementById('cameraSelect');
        select.innerHTML = '';
        videoDevices.forEach((device, idx) => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Camera ${idx + 1}`;
            select.appendChild(option);
        });
    }

    // ì›¹ìº  ì‹œì‘
    async function startCamera() {
        try {
            const selectedDeviceId = document.getElementById('cameraSelect').value;
            const constraints = {
                video: {
                    deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined,
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                }
            };

            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            const video = document.getElementById('video');
            video.srcObject = currentStream;
            
            // ë°°ê²½ í•™ìŠµ ì‹œì‘
            if (!backgroundModel) {
                startBackgroundLearning();
            }
        } catch (error) {
            console.error('ì¹´ë©”ë¼ ì ‘ê·¼ ì˜¤ë¥˜:', error);
            document.getElementById('result').innerText = 'ì¹´ë©”ë¼ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
        }
    }

    // ë°°ê²½ í•™ìŠµ ì‹œì‘
    function startBackgroundLearning() {
        isBackgroundLearning = true;
        backgroundFrameCount = 0;
        document.getElementById('result').innerText = 'ë°°ê²½ í•™ìŠµ ì¤‘... (ì•ˆì •ëœ ìƒíƒœë¥¼ ìœ ì§€í•´ ì£¼ì„¸ìš”)';
        
        const learningInterval = setInterval(() => {
            const video = document.getElementById('video');
            if (video.videoWidth === 0) return;
            
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            if (!backgroundModel) {
                // ì²« ë²ˆì§¸ í”„ë ˆì„ì„ ë°°ê²½ ëª¨ë¸ë¡œ ì´ˆê¸°í™”
                backgroundModel = new ImageData(
                    new Uint8ClampedArray(currentImageData.data),
                    currentImageData.width,
                    currentImageData.height
                );
            } else {
                // ë°°ê²½ ëª¨ë¸ ì—…ë°ì´íŠ¸ (í‰ê· í™”)
                updateBackgroundModel(currentImageData);
            }
            
            backgroundFrameCount++;
            
            if (backgroundFrameCount >= backgroundLearningFrames) {
                isBackgroundLearning = false;
                useBackgroundSubtraction = true;
                clearInterval(learningInterval);
                document.getElementById('result').innerText = 'ë°°ê²½ í•™ìŠµ ì™„ë£Œ! ë°°ê²½ ì°¨ë¶„ ëª¨ë“œ í™œì„±í™”ë¨';
                console.log('ë°°ê²½ í•™ìŠµ ì™„ë£Œ - ìµœì í™”ëœ ê°ì§€ ëª¨ë“œ ì‹œì‘');
            }
        }, 100);
    }

    // ë°°ê²½ ëª¨ë¸ ì—…ë°ì´íŠ¸
    function updateBackgroundModel(currentFrame) {
        const alpha = 0.1; // í•™ìŠµë¥ 
        for (let i = 0; i < backgroundModel.data.length; i += 4) {
            // RGB ì±„ë„ë§Œ ì—…ë°ì´íŠ¸ (ì•ŒíŒŒ ì±„ë„ ì œì™¸)
            backgroundModel.data[i] = backgroundModel.data[i] * (1 - alpha) + currentFrame.data[i] * alpha;
            backgroundModel.data[i + 1] = backgroundModel.data[i + 1] * (1 - alpha) + currentFrame.data[i + 1] * alpha;
            backgroundModel.data[i + 2] = backgroundModel.data[i + 2] * (1 - alpha) + currentFrame.data[i + 2] * alpha;
        }
    }

    // ë°°ê²½ ì°¨ë¶„ì„ í†µí•œ ì „ê²½ ì¶”ì¶œ
    function extractForeground(currentFrame) {
        if (!backgroundModel || !useBackgroundSubtraction) return null;
        
        const canvas = document.createElement('canvas');
        canvas.width = currentFrame.width;
        canvas.height = currentFrame.height;
        const ctx = canvas.getContext('2d');
        
        const foregroundData = new ImageData(canvas.width, canvas.height);
        const threshold = 30; // ì°¨ì´ ì„ê³„ê°’
        
        for (let i = 0; i < currentFrame.data.length; i += 4) {
            const diffR = Math.abs(currentFrame.data[i] - backgroundModel.data[i]);
            const diffG = Math.abs(currentFrame.data[i + 1] - backgroundModel.data[i + 1]);
            const diffB = Math.abs(currentFrame.data[i + 2] - backgroundModel.data[i + 2]);
            
            const totalDiff = (diffR + diffG + diffB) / 3;
            
            if (totalDiff > threshold) {
                // ì „ê²½ ê°ì²´ë¡œ íŒë‹¨
                foregroundData.data[i] = currentFrame.data[i];
                foregroundData.data[i + 1] = currentFrame.data[i + 1];
                foregroundData.data[i + 2] = currentFrame.data[i + 2];
                foregroundData.data[i + 3] = 255;
            } else {
                // ë°°ê²½ìœ¼ë¡œ íŒë‹¨
                foregroundData.data[i] = 0;
                foregroundData.data[i + 1] = 0;
                foregroundData.data[i + 2] = 0;
                foregroundData.data[i + 3] = 0;
            }
        }
        
        return foregroundData;
    }

    // ê°œì„ ëœ í”„ë ˆì„ ë³€í™” ê°ì§€ (ë°°ê²½ ì°¨ë¶„ ì ìš©)
    function detectFrameChange(currentImageData, previousImageData) {
        if (!previousImageData) return false;
        
        // ë°°ê²½ ì°¨ë¶„ ëª¨ë“œê°€ í™œì„±í™”ëœ ê²½ìš°
        if (useBackgroundSubtraction) {
            const foreground = extractForeground(currentImageData);
            if (!foreground) return false;
            
            // ì „ê²½ í”½ì…€ ë¹„ìœ¨ ê³„ì‚°
            let foregroundPixels = 0;
            const totalPixels = foreground.width * foreground.height;
            
            for (let i = 3; i < foreground.data.length; i += 4) {
                if (foreground.data[i] > 0) {
                    foregroundPixels++;
                }
            }
            
            const foregroundRatio = foregroundPixels / totalPixels;
            console.log(`ì „ê²½ ë¹„ìœ¨: ${(foregroundRatio * 100).toFixed(2)}%`);
            
            // ì „ê²½ ë¹„ìœ¨ì´ ì„ê³„ê°’ì„ ì´ˆê³¼í•˜ë©´ ì“°ë ˆê¸° ê°ì§€
            return foregroundRatio > 0.02; // 2% ì´ìƒì˜ ë³€í™”
        }
        
        // ê¸°ì¡´ ë°©ì‹ (ë°°ê²½ ì°¨ë¶„ ë¯¸ì‚¬ìš©)
        const totalPixels = currentImageData.width * currentImageData.height;
        let changedPixels = 0;
        const threshold = 30;

        for (let i = 0; i < currentImageData.data.length; i += 4) {
            const rDiff = Math.abs(currentImageData.data[i] - previousImageData.data[i]);
            const gDiff = Math.abs(currentImageData.data[i + 1] - previousImageData.data[i + 1]);
            const bDiff = Math.abs(currentImageData.data[i + 2] - previousImageData.data[i + 2]);
            
            if (rDiff + gDiff + bDiff > threshold) {
                changedPixels++;
            }
        }
        
        const changeRatio = changedPixels / totalPixels;
        console.log(`ë³€í™”ìœ¨: ${(changeRatio * 100).toFixed(2)}%`);
        return changeRatio > changeThreshold;
    }

    // í”„ë ˆì„ ëª¨ë‹ˆí„°ë§ í•¨ìˆ˜
    function monitorFrameChanges() {
        const video = document.getElementById('video');
        if (video.videoWidth === 0) return;
        
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        // ë°°ê²½ í•™ìŠµ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ë³€í™” ê°ì§€
        if (!isBackgroundLearning && !isProcessing && detectFrameChange(currentImageData, previousFrame)) {
            const detectionMode = useBackgroundSubtraction ? "ë°°ê²½ ì°¨ë¶„" : "í”„ë ˆì„ ì°¨ë¶„";
            console.log(`${detectionMode} ëª¨ë“œë¡œ ì“°ë ˆê¸° ê°ì§€ë¨ - 1ì´ˆ í›„ ë¶„ì„ ì‹œì‘`);
            document.getElementById('result').innerText = `ì“°ë ˆê¸° ê°ì§€ë¨ (${detectionMode}) - 1ì´ˆ í›„ ë¶„ì„ ì‹œì‘...`;
            
            isProcessing = true;
            setTimeout(() => {
                captureAndClassify();
            }, 1000);
        }
        
        // í˜„ì¬ í”„ë ˆì„ì„ ì´ì „ í”„ë ˆì„ìœ¼ë¡œ ì €ì¥
        previousFrame = currentImageData;
    }

    // ë°°ê²½ ì¬í•™ìŠµ ê¸°ëŠ¥
    function relearnBackground() {
        backgroundModel = null;
        useBackgroundSubtraction = false;
        startBackgroundLearning();
    }

    // ê¸°ì¡´ í•¨ìˆ˜ë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€...
    async function captureAndClassify() {
        // isProcessingì€ ì´ë¯¸ monitorFrameChangesì—ì„œ ì„¤ì •ë¨
        
        const video = document.getElementById('video');
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        canvas.toBlob(async (blob) => {
            const formData = new FormData();
            formData.append('file', blob, 'image.jpg');
            
            try {
                const response = await fetch('/predict', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const result = await response.json();
                    const label = result.label;
                    const confidence = result.confidence;
                    
                    console.log(`ë¶„ë¥˜ ê²°ê³¼: ${label} (ì‹ ë¢°ë„: ${confidence}%)`);
                    document.getElementById('result').innerText = `ë¶„ë¥˜ ê²°ê³¼: ${label} (${confidence}%)`;
                    
                    if (auto && port && writer && label !== lastLabel) {
                        const currentTime = Date.now();
                        if (currentTime - lastSend > 2000) {
                            await sendCommand(label);
                            lastLabel = label;
                            lastSend = currentTime;
                        }
                    }
                } else {
                    throw new Error('ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜');
                }
            } catch (error) {
                console.error('ë¶„ë¥˜ ì˜¤ë¥˜:', error);
                document.getElementById('result').innerText = 'ë¶„ë¥˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
            } finally {
                // 3ì´ˆ í›„ ë‹¤ì‹œ ê°ì§€ ê°€ëŠ¥í•˜ë„ë¡ ì„¤ì •
                setTimeout(() => {
                    isProcessing = false;
                    if (useBackgroundSubtraction) {
                        document.getElementById('result').innerText = 'ë°°ê²½ ì°¨ë¶„ ëª¨ë“œë¡œ ëŒ€ê¸° ì¤‘...';
                    } else {
                        document.getElementById('result').innerText = 'í”„ë ˆì„ ì°¨ë¶„ ëª¨ë“œë¡œ ëŒ€ê¸° ì¤‘...';
                    }
                }, 3000);
            }
        }, 'image/jpeg', 0.8);
    }

    // ë‚˜ë¨¸ì§€ ê¸°ì¡´ í•¨ìˆ˜ë“¤...
    async function connectSerial() {
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 9600 });
            writer = port.writable.getWriter();
            document.getElementById('status').innerText = 'ì‹œë¦¬ì–¼ ì—°ê²°ë¨';
        } catch (error) {
            console.error('ì‹œë¦¬ì–¼ ì—°ê²° ì˜¤ë¥˜:', error);
            document.getElementById('status').innerText = 'ì‹œë¦¬ì–¼ ì—°ê²° ì‹¤íŒ¨';
        }
    }

    async function sendCommand(label) {
        if (!writer) return;
        
        const commands = {
            'cardboard': '1\n',
            'glass': '2\n', 
            'metal': '3\n',
            'paper': '4\n',
            'plastic': '5\n',
            'trash': '6\n'
        };
        
        const command = commands[label] || '0\n';
        
        try {
            await writer.write(new TextEncoder().encode(command));
            console.log(`ëª…ë ¹ ì „ì†¡: ${command.trim()}`);
        } catch (error) {
            console.error('ëª…ë ¹ ì „ì†¡ ì˜¤ë¥˜:', error);
        }
    }

    function toggleAuto() {
        auto = !auto;
        const button = document.getElementById('autoBtn');
        
        if (auto) {
            button.innerText = 'ìë™ ë¶„ë¥˜ ì¤‘ì§€';
            button.style.backgroundColor = '#dc3545';
            document.getElementById('result').innerText = 'ìë™ ë¶„ë¥˜ ëª¨ë“œ ì‹œì‘ - ì“°ë ˆê¸°ë¥¼ ë„£ì–´ì£¼ì„¸ìš”';
            
            intervalId = setInterval(monitorFrameChanges, 500);
        } else {
            button.innerText = 'ìë™ ë¶„ë¥˜ ì‹œì‘';
            button.style.backgroundColor = '#28a745';
            document.getElementById('result').innerText = 'ìë™ ë¶„ë¥˜ ëª¨ë“œ ì¤‘ì§€ë¨';
            
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            isProcessing = false;
        }
    }

    // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
    window.addEventListener('DOMContentLoaded', () => {
        updateCameraList();
        startCamera();
    });
    </script>
    
    <!-- ë°°ê²½ ìµœì í™” ì»¨íŠ¸ë¡¤ ì¶”ê°€ -->
    <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">
        <h4>ğŸ¯ ë°°ê²½ ìµœì í™” ì„¤ì •</h4>
        <button onclick="relearnBackground()" style="padding: 8px 16px; margin: 5px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer;">
            ë°°ê²½ ì¬í•™ìŠµ
        </button>
        <div id="backgroundStatus" style="margin-top: 10px; font-size: 14px; color: #666;">
            ë°°ê²½ ëª¨ë¸ ìƒíƒœ: í•™ìŠµ ëŒ€ê¸° ì¤‘
        </div>
    </div>
</body>
</html> 