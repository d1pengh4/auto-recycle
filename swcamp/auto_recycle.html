<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>자동 분리수거 기계 (Auto Recycle Machine)</title>
    <style>
        body { font-family: Arial, sans-serif; background: #f4f4f4; margin: 0; padding: 0; }
        .container { max-width: 500px; margin: 50px auto; background: #fff; padding: 30px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        h1 { text-align: center; }
        #result { margin-top: 20px; font-size: 1.2em; text-align: center; }
        input[type="file"] { display: block; margin: 20px auto; }
        button { display: block; margin: 0 auto; padding: 10px 20px; font-size: 1em; }
        #video { display: block; margin: 0 auto; border-radius: 10px; background: #222; }
    </style>
</head>
<body>
    <div class="container">
        <h1>자동 분리수거 기계<br><small>Auto Recycle Machine</small></h1>
        <select id="cameraSelect" style="display:block; margin:10px auto; padding:5px 10px;"></select>
        <video id="video" width="320" height="240" autoplay playsinline></video>
        <div style="margin:10px 0; text-align:center;">
            <button onclick="toggleAuto()" id="autoBtn">자동 분류 시작</button>
            <button onclick="connectSerial()">아두이노 연결</button>
        </div>
        <div id="result">분류 결과가 여기에 표시됩니다</div>
    </div>
    <script>
    let auto = false, intervalId = null, port = null, writer = null, lastLabel = '', lastSend = 0;
    let currentStream = null;
    let previousFrame = null; // 이전 프레임을 저장할 변수
    let changeThreshold = 0.05; // 변화 감지 임계값 (5%)
    let isProcessing = false; // 현재 분류 처리 중인지 확인
    
    // 배경 최적화 관련 변수들
    let backgroundModel = null; // 배경 모델
    let isBackgroundLearning = false; // 배경 학습 중인지 확인
    let backgroundFrameCount = 0; // 배경 학습용 프레임 카운트
    let backgroundLearningFrames = 30; // 배경 학습에 필요한 프레임 수
    let useBackgroundSubtraction = false; // 배경 차분 사용 여부

    // 카메라 목록 불러오기 및 선택
    async function updateCameraList() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        const select = document.getElementById('cameraSelect');
        select.innerHTML = '';
        videoDevices.forEach((device, idx) => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Camera ${idx + 1}`;
            select.appendChild(option);
        });
    }

    // 웹캠 시작
    async function startCamera() {
        try {
            const selectedDeviceId = document.getElementById('cameraSelect').value;
            const constraints = {
                video: {
                    deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined,
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                }
            };

            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            const video = document.getElementById('video');
            video.srcObject = currentStream;
            
            // 배경 학습 시작
            if (!backgroundModel) {
                startBackgroundLearning();
            }
        } catch (error) {
            console.error('카메라 접근 오류:', error);
            document.getElementById('result').innerText = '카메라에 접근할 수 없습니다.';
        }
    }

    // 배경 학습 시작
    function startBackgroundLearning() {
        isBackgroundLearning = true;
        backgroundFrameCount = 0;
        document.getElementById('result').innerText = '배경 학습 중... (안정된 상태를 유지해 주세요)';
        
        const learningInterval = setInterval(() => {
            const video = document.getElementById('video');
            if (video.videoWidth === 0) return;
            
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            if (!backgroundModel) {
                // 첫 번째 프레임을 배경 모델로 초기화
                backgroundModel = new ImageData(
                    new Uint8ClampedArray(currentImageData.data),
                    currentImageData.width,
                    currentImageData.height
                );
            } else {
                // 배경 모델 업데이트 (평균화)
                updateBackgroundModel(currentImageData);
            }
            
            backgroundFrameCount++;
            
            if (backgroundFrameCount >= backgroundLearningFrames) {
                isBackgroundLearning = false;
                useBackgroundSubtraction = true;
                clearInterval(learningInterval);
                document.getElementById('result').innerText = '배경 학습 완료! 배경 차분 모드 활성화됨';
                console.log('배경 학습 완료 - 최적화된 감지 모드 시작');
            }
        }, 100);
    }

    // 배경 모델 업데이트
    function updateBackgroundModel(currentFrame) {
        const alpha = 0.1; // 학습률
        for (let i = 0; i < backgroundModel.data.length; i += 4) {
            // RGB 채널만 업데이트 (알파 채널 제외)
            backgroundModel.data[i] = backgroundModel.data[i] * (1 - alpha) + currentFrame.data[i] * alpha;
            backgroundModel.data[i + 1] = backgroundModel.data[i + 1] * (1 - alpha) + currentFrame.data[i + 1] * alpha;
            backgroundModel.data[i + 2] = backgroundModel.data[i + 2] * (1 - alpha) + currentFrame.data[i + 2] * alpha;
        }
    }

    // 배경 차분을 통한 전경 추출
    function extractForeground(currentFrame) {
        if (!backgroundModel || !useBackgroundSubtraction) return null;
        
        const canvas = document.createElement('canvas');
        canvas.width = currentFrame.width;
        canvas.height = currentFrame.height;
        const ctx = canvas.getContext('2d');
        
        const foregroundData = new ImageData(canvas.width, canvas.height);
        const threshold = 30; // 차이 임계값
        
        for (let i = 0; i < currentFrame.data.length; i += 4) {
            const diffR = Math.abs(currentFrame.data[i] - backgroundModel.data[i]);
            const diffG = Math.abs(currentFrame.data[i + 1] - backgroundModel.data[i + 1]);
            const diffB = Math.abs(currentFrame.data[i + 2] - backgroundModel.data[i + 2]);
            
            const totalDiff = (diffR + diffG + diffB) / 3;
            
            if (totalDiff > threshold) {
                // 전경 객체로 판단
                foregroundData.data[i] = currentFrame.data[i];
                foregroundData.data[i + 1] = currentFrame.data[i + 1];
                foregroundData.data[i + 2] = currentFrame.data[i + 2];
                foregroundData.data[i + 3] = 255;
            } else {
                // 배경으로 판단
                foregroundData.data[i] = 0;
                foregroundData.data[i + 1] = 0;
                foregroundData.data[i + 2] = 0;
                foregroundData.data[i + 3] = 0;
            }
        }
        
        return foregroundData;
    }

    // 개선된 프레임 변화 감지 (배경 차분 적용)
    function detectFrameChange(currentImageData, previousImageData) {
        if (!previousImageData) return false;
        
        // 배경 차분 모드가 활성화된 경우
        if (useBackgroundSubtraction) {
            const foreground = extractForeground(currentImageData);
            if (!foreground) return false;
            
            // 전경 픽셀 비율 계산
            let foregroundPixels = 0;
            const totalPixels = foreground.width * foreground.height;
            
            for (let i = 3; i < foreground.data.length; i += 4) {
                if (foreground.data[i] > 0) {
                    foregroundPixels++;
                }
            }
            
            const foregroundRatio = foregroundPixels / totalPixels;
            console.log(`전경 비율: ${(foregroundRatio * 100).toFixed(2)}%`);
            
            // 전경 비율이 임계값을 초과하면 쓰레기 감지
            return foregroundRatio > 0.02; // 2% 이상의 변화
        }
        
        // 기존 방식 (배경 차분 미사용)
        const totalPixels = currentImageData.width * currentImageData.height;
        let changedPixels = 0;
        const threshold = 30;

        for (let i = 0; i < currentImageData.data.length; i += 4) {
            const rDiff = Math.abs(currentImageData.data[i] - previousImageData.data[i]);
            const gDiff = Math.abs(currentImageData.data[i + 1] - previousImageData.data[i + 1]);
            const bDiff = Math.abs(currentImageData.data[i + 2] - previousImageData.data[i + 2]);
            
            if (rDiff + gDiff + bDiff > threshold) {
                changedPixels++;
            }
        }
        
        const changeRatio = changedPixels / totalPixels;
        console.log(`변화율: ${(changeRatio * 100).toFixed(2)}%`);
        return changeRatio > changeThreshold;
    }

    // 프레임 모니터링 함수
    function monitorFrameChanges() {
        const video = document.getElementById('video');
        if (video.videoWidth === 0) return;
        
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        // 배경 학습 중이 아닐 때만 변화 감지
        if (!isBackgroundLearning && !isProcessing && detectFrameChange(currentImageData, previousFrame)) {
            const detectionMode = useBackgroundSubtraction ? "배경 차분" : "프레임 차분";
            console.log(`${detectionMode} 모드로 쓰레기 감지됨 - 1초 후 분석 시작`);
            document.getElementById('result').innerText = `쓰레기 감지됨 (${detectionMode}) - 1초 후 분석 시작...`;
            
            isProcessing = true;
            setTimeout(() => {
                captureAndClassify();
            }, 1000);
        }
        
        // 현재 프레임을 이전 프레임으로 저장
        previousFrame = currentImageData;
    }

    // 배경 재학습 기능
    function relearnBackground() {
        backgroundModel = null;
        useBackgroundSubtraction = false;
        startBackgroundLearning();
    }

    // 기존 함수들은 그대로 유지...
    async function captureAndClassify() {
        // isProcessing은 이미 monitorFrameChanges에서 설정됨
        
        const video = document.getElementById('video');
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        canvas.toBlob(async (blob) => {
            const formData = new FormData();
            formData.append('file', blob, 'image.jpg');
            
            try {
                const response = await fetch('/predict', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const result = await response.json();
                    const label = result.label;
                    const confidence = result.confidence;
                    
                    console.log(`분류 결과: ${label} (신뢰도: ${confidence}%)`);
                    document.getElementById('result').innerText = `분류 결과: ${label} (${confidence}%)`;
                    
                    if (auto && port && writer && label !== lastLabel) {
                        const currentTime = Date.now();
                        if (currentTime - lastSend > 2000) {
                            await sendCommand(label);
                            lastLabel = label;
                            lastSend = currentTime;
                        }
                    }
                } else {
                    throw new Error('서버 응답 오류');
                }
            } catch (error) {
                console.error('분류 오류:', error);
                document.getElementById('result').innerText = '분류 중 오류가 발생했습니다.';
            } finally {
                // 3초 후 다시 감지 가능하도록 설정
                setTimeout(() => {
                    isProcessing = false;
                    if (useBackgroundSubtraction) {
                        document.getElementById('result').innerText = '배경 차분 모드로 대기 중...';
                    } else {
                        document.getElementById('result').innerText = '프레임 차분 모드로 대기 중...';
                    }
                }, 3000);
            }
        }, 'image/jpeg', 0.8);
    }

    // 나머지 기존 함수들...
    async function connectSerial() {
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 9600 });
            writer = port.writable.getWriter();
            document.getElementById('status').innerText = '시리얼 연결됨';
        } catch (error) {
            console.error('시리얼 연결 오류:', error);
            document.getElementById('status').innerText = '시리얼 연결 실패';
        }
    }

    async function sendCommand(label) {
        if (!writer) return;
        
        const commands = {
            'cardboard': '1\n',
            'glass': '2\n', 
            'metal': '3\n',
            'paper': '4\n',
            'plastic': '5\n',
            'trash': '6\n'
        };
        
        const command = commands[label] || '0\n';
        
        try {
            await writer.write(new TextEncoder().encode(command));
            console.log(`명령 전송: ${command.trim()}`);
        } catch (error) {
            console.error('명령 전송 오류:', error);
        }
    }

    function toggleAuto() {
        auto = !auto;
        const button = document.getElementById('autoBtn');
        
        if (auto) {
            button.innerText = '자동 분류 중지';
            button.style.backgroundColor = '#dc3545';
            document.getElementById('result').innerText = '자동 분류 모드 시작 - 쓰레기를 넣어주세요';
            
            intervalId = setInterval(monitorFrameChanges, 500);
        } else {
            button.innerText = '자동 분류 시작';
            button.style.backgroundColor = '#28a745';
            document.getElementById('result').innerText = '자동 분류 모드 중지됨';
            
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            isProcessing = false;
        }
    }

    // 페이지 로드 시 초기화
    window.addEventListener('DOMContentLoaded', () => {
        updateCameraList();
        startCamera();
    });
    </script>
    
    <!-- 배경 최적화 컨트롤 추가 -->
    <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">
        <h4>🎯 배경 최적화 설정</h4>
        <button onclick="relearnBackground()" style="padding: 8px 16px; margin: 5px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer;">
            배경 재학습
        </button>
        <div id="backgroundStatus" style="margin-top: 10px; font-size: 14px; color: #666;">
            배경 모델 상태: 학습 대기 중
        </div>
    </div>
</body>
</html> 